import { useState, useCallback } from 'react';
import {
  type TransformerContext,
  type CombatSession,
  type WorldEvent,
  type ActorURN,
  type PlaceURN,
  createIntent,
  resolveCommandFromIntent,
  executeCommand,
  type Command,
} from '@flux/core';
import { ALICE_ID } from '~/apps/combat/constants';

export interface UseCombatStateResult {
  executeIntent: (intentText: string) => WorldEvent[];
  executeCommand: (command: Command) => WorldEvent[];
  lastEventId: string | null;
}

export interface CombatStateDependencies {
  createIntent: typeof createIntent;
  resolveCommandFromIntent: typeof resolveCommandFromIntent;
  executeCommand: typeof executeCommand;
}

export const DEFAULT_COMBAT_STATE_DEPS: CombatStateDependencies = {
  createIntent,
  resolveCommandFromIntent,
  executeCommand,
};

/**
 * Hook that manages combat session state and command execution
 * Uses the universal intent execution system from @flux/core
 */
export function useCombatState(
  context: TransformerContext,
  session: CombatSession | null,
  currentActorId: ActorURN | null,
  placeId: PlaceURN,
  deps: CombatStateDependencies = DEFAULT_COMBAT_STATE_DEPS
): UseCombatStateResult {
  const [lastEventId, setLastEventId] = useState<string | null>(null);

  const executeIntent = useCallback((intentText: string): WorldEvent[] => {
    // Return early if not initialized
    if (!currentActorId || !session) {
      return [];
    }

    // Derive session ID from the session object
    const sessionId = session.id;

    try {
      // Clear any previously accumulated events to prevent overlap
      context.resetEvents();
      context.resetErrors();

      // Step 1: Create Intent with explicit session context
      const intent = deps.createIntent({
        id: `combat-intent-${Date.now()}`,
        actor: currentActorId,
        location: placeId,
        session: sessionId, // üéØ Explicit session threading from session.id!
        text: intentText,
      });

      // Step 2: Resolve Intent to Command
      const resolvedCommand = deps.resolveCommandFromIntent(context, intent);

      if (!resolvedCommand) {
        console.warn('Failed to resolve command:', intentText);
        return [];
      }

      // Step 3: Execute Command
      deps.executeCommand(context, resolvedCommand);

      // Get all events generated by this command
      const newEvents = context.getDeclaredEvents();
      const newErrors = context.getDeclaredErrors();

      if (newErrors.length > 0) {
        for (const error of newErrors) {
          console.error('executeCommand failed:', error);
        }
      }

      // Trigger re-render by updating event count
      if (newEvents.length > 0) {
        for (const event of newEvents) {
          console.log(`${event.actor} ${event.type} ${JSON.stringify(event.payload)}`);
          if (event.type === 'combat:actor:moved') {
            const alice = session?.data.combatants.get(ALICE_ID);
            console.log('üîç MOVE EVENT DETAILS:', JSON.stringify(event.payload, null, 2));
            console.log('üîç SESSION AFTER MOVE - ID:', session?.id, 'Alice pos:', alice?.position.coordinate);
          }
        }
        // Update last event ID for re-render triggering
        const latestEvent = newEvents[newEvents.length - 1];
        setLastEventId(latestEvent.id);
      }

      return newEvents;
    } catch (error) {
      console.error('executeCommand failed:', error);
      return [];
    }
  }, [currentActorId, context, session, placeId, deps]);

  const executeCommand = useCallback((command: Command): WorldEvent[] => {
    // Return early if not initialized
    if (!currentActorId || !session) {
      return [];
    }

    try {
      // Clear any previously accumulated events to prevent overlap
      context.resetEvents();
      context.resetErrors();

      // Direct command execution - bypass intent resolution
      deps.executeCommand(context, command);

      // Get all events generated by this command
      const newEvents = context.getDeclaredEvents();
      const newErrors = context.getDeclaredErrors();

      if (newErrors.length > 0) {
        for (const error of newErrors) {
          console.error('executeCommand failed:', error);
        }
      }

      // Trigger re-render by updating event count
      if (newEvents.length > 0) {
        for (const event of newEvents) {
          console.log(`${event.actor} ${event.type} ${JSON.stringify(event.payload)}`);
          if (event.type === 'combat:actor:moved') {
            const alice = session?.data.combatants.get(ALICE_ID);
            console.log('üîç MOVE EVENT DETAILS:', JSON.stringify(event.payload, null, 2));
            console.log('üîç SESSION AFTER MOVE - ID:', session?.id, 'Alice pos:', alice?.position.coordinate);
          }
        }
        // Update last event ID for re-render triggering
        const latestEvent = newEvents[newEvents.length - 1];
        setLastEventId(latestEvent.id);
      }

      return newEvents;
    } catch (error) {
      console.error('executeCommand failed:', error);
      return [];
    }
  }, [currentActorId, context, session, deps]);

  return { executeIntent, executeCommand, lastEventId };
}
