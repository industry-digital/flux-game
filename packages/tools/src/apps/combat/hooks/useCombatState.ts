import { useState, useCallback } from 'react';
import {
  type TransformerContext,
  type CombatSession,
  type WorldEvent,
  type ActorURN,
  type PlaceURN,
  createIntent,
  resolveCommandFromIntent,
  executeCommand,
  type Command,
  type PotentiallyImpureOperations,
  type ExecutionError,
} from '@flux/core';

export interface UseCombatStateResult {
  executeIntent: (intentText: string) => WorldEvent[];
  executeCommand: (command: Command) => WorldEvent[];
  lastEventId: string | null;
}

export interface CombatStateDependencies {
  createIntent: typeof createIntent;
  resolveCommandFromIntent: typeof resolveCommandFromIntent;
  executeCommand: typeof executeCommand;
  timestamp: PotentiallyImpureOperations['timestamp'];
}

export const DEFAULT_COMBAT_STATE_DEPS: CombatStateDependencies = {
  createIntent,
  resolveCommandFromIntent,
  executeCommand,
  timestamp: () => Date.now(),
};

const ESCAPED_QUOTE_REGEX = /\\\"/g;

const stripSlashes = (json: string): string => {
  return json.replace(ESCAPED_QUOTE_REGEX, '"');
};

/**
 * Hook that manages combat session state and command execution
 * Uses the universal intent execution system from @flux/core
 */
export function useCombatState(
  context: TransformerContext,
  session: CombatSession | null,
  currentActorId: ActorURN | null,
  placeId: PlaceURN,
  deps: CombatStateDependencies = DEFAULT_COMBAT_STATE_DEPS
): UseCombatStateResult {
  const [lastEventId, setLastEventId] = useState<string | null>(null);

  const logEvents = useCallback((events: WorldEvent[]) => {
    for (const event of events) {
      console.log(event.actor, event.type, stripSlashes(JSON.stringify(event.payload)));
    }
  }, []);

  const logErrors = useCallback((errors: ExecutionError[]) => {
    for (const error of errors) {
      console.error('executeCommand failed:', error.error.stack);
    }
  }, []);

  const executeIntent = useCallback((intentText: string): WorldEvent[] => {
    // Validate required state - these should never be null when executing intents
    if (!currentActorId) {
      throw new Error(`Cannot execute intent "${intentText}": currentActorId is required but was ${currentActorId}`);
    }

    if (!session) {
      throw new Error(`Cannot execute intent "${intentText}": session is required but was null`);
    }

    // Check if the current actor exists in the world projection
    const actorInWorld = context.world.actors[currentActorId];
    if (!actorInWorld) {
      throw new Error(`Cannot execute intent "${intentText}": actor "${currentActorId}" not found in world projection. Available actors: [${Object.keys(context.world.actors).join(', ')}]`);
    }

    // Derive session ID from the session object
    const sessionId = session.id;

    try {
      // Clear any previously accumulated events to prevent overlap
      context.resetEvents();
      context.resetErrors();

      // Step 1: Create Intent with explicit session context
      const intent = deps.createIntent({
        id: context.uniqid(),
        actor: currentActorId,
        location: placeId,
        session: sessionId, // ðŸŽ¯ Explicit session threading from session.id!
        text: intentText,
      });

      // Step 2: Resolve Intent to Command
      const resolvedCommand = deps.resolveCommandFromIntent(context, intent);

      if (!resolvedCommand) {
        console.warn('Failed to resolve command:', intentText);
        return [];
      }

      // Step 3: Execute Command
      deps.executeCommand(context, resolvedCommand);

      const newEvents = context.getDeclaredEvents();
      const newErrors = context.getDeclaredErrors();

      logEvents(newEvents);
      logErrors(newErrors);

      // Trigger re-render by updating event count
      if (newEvents.length > 0) {
        // Update last event ID for re-render triggering
        const latestEvent = newEvents[newEvents.length - 1];
        setLastEventId(latestEvent.id);
      }

      return newEvents;
    } catch (error) {
      console.error('executeCommand failed:', error);
      return [];
    }
  }, [currentActorId, context, session, placeId, deps]);

  const executeCommand = useCallback((command: Command): WorldEvent[] => {
    // Validate required state - these should never be null when executing commands
    if (!currentActorId) {
      throw new Error(`Cannot execute command: currentActorId is required but was ${currentActorId}`);
    }

    if (!session) {
      throw new Error(`Cannot execute command: session is required but was null`);
    }

    try {
      // Clear any previously accumulated events to prevent overlap
      context.resetEvents();
      context.resetErrors();

      // Direct command execution - bypass intent resolution
      deps.executeCommand(context, command);

      // Get all events generated by this command
      const newEvents = context.getDeclaredEvents();
      const newErrors = context.getDeclaredErrors();

      logEvents(newEvents);
      logErrors(newErrors);

      // Trigger re-render by updating event count
      if (newEvents.length > 0) {
        // Update last event ID for re-render triggering
        const latestEvent = newEvents[newEvents.length - 1];
        setLastEventId(latestEvent.id);
      }

      return newEvents;
    } catch (error) {
      console.error('executeCommand failed:', error);
      return [];
    }
  }, [currentActorId, context, session, deps]);

  return { executeIntent, executeCommand, lastEventId };
}
