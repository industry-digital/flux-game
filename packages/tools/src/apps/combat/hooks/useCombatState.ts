import { useState, useCallback, useEffect } from 'react';
import {
  executeIntent,
  type TransformerContext,
  type CombatSession,
  type WorldEvent,
  type ActorURN,
  type PlaceURN,
  type SessionURN,
} from '@flux/core';

export interface CombatState {
  session: CombatSession | null;
  eventCount: number;
}

export interface UseCombatStateResult {
  state: CombatState;
  executeCommand: (command: string) => WorldEvent[];
}

export interface CombatStateDependencies {
  executeIntent: typeof executeIntent;
}

export const DEFAULT_COMBAT_STATE_DEPS: CombatStateDependencies = {
  executeIntent,
};

const serializeEventPayload = (payload: any): string => {
  let keys = [];
  let values = [];
  for (let key in payload) {
    keys.push(key);
    values.push(payload[key]);
  }

  const result = Array(keys.length);
  for (let i = 0; i < keys.length; i++) {
    result[i] = `${keys[i]}=${values[i]}`;
  }

  return result.join(', ');
}

/**
 * Hook that manages combat session state and command execution
 * Uses the universal intent execution system from @flux/core
 */
export function useCombatState(
  context: TransformerContext,
  initialSession: CombatSession | null,
  currentActorId: ActorURN | null,
  _placeId: PlaceURN,
  _sessionId?: SessionURN | null,
  deps: CombatStateDependencies = DEFAULT_COMBAT_STATE_DEPS
): UseCombatStateResult {
  const [state, setState] = useState<CombatState>({
    session: initialSession,
    eventCount: 0
  });

  // Update internal state when initialSession changes
  useEffect(() => {
    if (initialSession && !state.session) {
      setState({ session: initialSession, eventCount: 0 });
    }
  }, [initialSession, state.session]);

  const executeCommand = useCallback((command: string): WorldEvent[] => {
    // Return early if not initialized
    if (!currentActorId || !state.session) {
      return [];
    }

    try {
      // Clear any previously accumulated events to prevent overlap
      context.resetEvents();
      context.resetErrors();

      // Use the universal intent execution system
      // This automatically handles intent resolution and command execution
      deps.executeIntent(context, currentActorId, command);

      // Get all events generated by this command
      const newEvents = context.getDeclaredEvents();
      const newErrors = context.getDeclaredErrors();

      if (newErrors.length > 0) {
        for (const error of newErrors) {
          console.error('executeCommand failed:', error);
        }
      }

      // Trigger re-render by updating event count
      if (newEvents.length > 0) {
        for (const event of newEvents) {
          console.log(`${event.actor} ${event.type} ${serializeEventPayload(event.payload)}`);
        }
        setState(prev => ({
          session: prev.session, // Same session object, but mutated by executeIntent
          eventCount: prev.eventCount + newEvents.length
        }));
      }

      return newEvents;
    } catch (error) {
      console.error('executeCommand failed:', error);
      return [];
    }
  }, [currentActorId, context, state.session, deps]);

  return { state, executeCommand };
}
