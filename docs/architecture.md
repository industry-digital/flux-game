# Flux Game Logic: Architectural Overview

This document outlines the design of our game logic package, which provides a pure functional interface for building multiplayer text-based games (MUDs). The architecture guarantees that any command or batch of commands will complete in exactly three database round-trips, with O(log n) query performance characteristics.

## Core Properties

- **Three Round-Trip Guarantee**: Every command, from simple movement to complex combat, completes in exactly three database round-trips regardless of complexity
- **Perfect Batching**: Processing 1000 commands requires the same three round-trips as processing one command
- **Pure Functional Core**: All game logic is implemented as pure functions that transform world state projections
- **Event Declaration**: Side effects are declared, not executed, enabling perfect batching and atomic processing
- **Type Safety**: Comprehensive TypeScript types ensure correct command handling and state transformations

## Writing Game Logic

Game logic in Flux is written like console game development - pure functions that transform state and declare events:

```typescript
export const MoveCommandReducer: Transformer<CommandType.MOVE, MoveCommandArgs> = (context, command) => {
  const { move } = useActorMovement(context);
  const { direction } = command.args;
  move(direction);
  return context;
};
```

The execution environment handles all performance concerns, allowing developers to focus purely on game mechanics and business logic.

# Flux Simulation Project: Architectural Overview



## Introduction

This document outlines the architectural design of our multiplayer text-based game (MUD), with a central emphasis on emergent gameplay and **predictable performance guarantees**.

A MUD (Multi-User Dungeon) is a text-based virtual world where players interact with the environment and each other through written commands, receiving rich narrative descriptions in return; they are the earliest form of online multiplayer games and remain compelling due to their focus on imagination, narrative depth, and complex world simulation.

Our goal is to foster rich, unscripted experiences that arise from the interplay of simulation systems, player actions, and AI-driven world elements. The architecture is deliberately structured to encourage surprising outcomes and dynamic narrative developments—where the world feels alive not because it is prewritten, but because it is reactive, systemic, and full of possibility.

## Executive Summary

Our MUD architecture is built on four key pillars:

1. **Emergent Gameplay** - Complex behavior emerges from simple systems interacting through taxonomic relationships
2. **XMPP-Based Communication** - Using a proven messaging protocol as a spatial simulation framework
3. **Reducer-Based Processing** - Pure, deterministic state transformations with clear separation of concerns
4. **Distributed Simulation** - Independent services that create a living world through autonomous agents

The system uses a five-stage processing pipeline for all world interactions, with a strict separation between pure game logic and side effects. All interactions flow through this pipeline, ensuring consistent behavior and enabling complex emergent phenomena to arise organically from the interaction of simple systems.

### Performance Guarantees

**3 Database Round-Trip Maximum**: Every world interaction, from raw text input to world mutation, is guaranteed to complete within exactly 3 database round-trips regardless of complexity. This is achieved through perfect batching, atomic JSONB partial updates, and lock-free concurrency control.

**Constant Round-Trip Batch Processing**: Our HTTP API accepts batches of commands that maintain the same 3 round-trip guarantee regardless of batch size. Individual queries scale at O(log n) due to PostgreSQL's B-tree primary key performance, providing exceptional scaling characteristics for multiplayer scenarios.

## Design Philosophy

### Emergent Gameplay as First Principle

When we talk about "emergence," we are referring to game outcomes or phenomena that are not explicitly scripted but instead arise from the complex interplay of our data-driven world, the independent actions of entities within it, and the dynamic content generated by AI. These behaviors can surprise even the creators of the game, as they are not directly programmed but rather emerge from the interactions of simpler components.

At the heart of our design is the desire to foster emergent behaviors that arise from the interactions of players, NPCs, and the environment. We want to create a world where players can discover unexpected new strategies, tactics, and stories through their actions and interactions with others. It's not our job as creators of the world to tell the player everything about it. It is up to the player to discover the world and its secrets.

In our architecture, emergence is primarily driven by:

**Data-Driven Design with Rich Taxonomic Semantics:** Our game world is built upon a foundation of richly structured data, where entities and their properties are defined and categorized according to a clearly defined taxonomy. This deep semantic layering allows for a multitude of potential interactions based on the inherent characteristics and relationships encoded within the entity data model itself. The game's systems are designed to react to these data points in consistent ways, leading to complex outcomes as different data sets interact.

*Example*: A creature with the taxonomic classification `flux:type:monster:elemental:fire` will react differently to an environment tagged `flux:climate:wet` than one tagged `flux:climate:arid`, potentially leading to unexpected combat behaviors or environmental effects.

**Interplay of Independent Entities:** Players, NPCs, environmental simulations, and even AI-driven content generators operate as independent agents within the shared world. Their actions are not centrally orchestrated in a rigid, linear fashion. Instead, each entity reacts to the current world state based on its own rules and goals. The simultaneous and often uncoordinated actions of these independent entities can lead to complex chains of events and surprising outcomes.

*Example*: A player's attempt to trade with a merchant (an independent NPC with its own economic motivations) in a town affected by a simulated economic downturn might lead to unexpected prices or even a refusal to trade, creating emergent economic challenges and opportunities.

**LLM-Driven Dynamic Content:** Our integration of modern large language models allows for the generation of dynamic content, such as entity descriptions, NPC dialogue, and even quest elements, that can react in novel and contextually relevant ways to the current state of the world and player actions. This AI-driven responsiveness introduces an element of unpredictability and can lead to emergent narrative possibilities and surprising interactions that were not explicitly authored.

*Example*: An NPC whose initial description was LLM-generated might react to a player character's reputation (a data point tracked by the system) in a way that reflects that reputation in their dialogue, creating an emergent social interaction that feels personalized and dynamic.

### Case Study: The Wedding Massacre

Imagine a player hosting an elaborate wedding in Oakhollow's town square (`flux:event:social:wedding`).

A guard confronts a troublemaker at the ceremony, landing a critical hit that severs the infiltrator's hand (`flux:anatomy:hand`). The severed hand drops a napalm grenade, which explodes.

This creates a precise taxonomic convergence that would normally never occur:
- A sacred union (`flux:place:ceremonial`) becomes a place of bloodshed
- The napalm grenade's specific damage type (`flux:damage:unholy:fire`) interacts with the wedding altar's material (`flux:material:blessed:wood`)
- All occurring during the dark moon (`flux:time:darkmoon`)

When unholy fire burns blessed wood during a dark moon, the World Server recognizes this rare pattern and triggers `flux:event:invasion:demonic` - powerful demons materialize and attack the wedding guests.

No designer explicitly programmed this specific chain of events. Instead, the underlying simulation evaluates taxonomic patterns that arise naturally from interactions between entities, materials, and world states. The same wedding disrupted by a regular explosive would have ended with just structural damage - demonstrating how emergence creates dynamic experiences from overlapping rule systems.

### Supporting Architectural Principles

**XMPP as a Spatial Simulation Protocol:** We use the Extensible Messaging and Presence Protocol (XMPP) not just as a communication fabric, but as a spatial simulation protocol. Each `Place` in the game world is modeled as a Multi-User Chat (MUC) room, and the movement of entities through space is mirrored by their traversal through MUCs. This choice gives us sophisticated messaging primitives for free while mapping naturally to MUD spatial concepts.

**Prioritizing Scalability and Performance:** To ensure the game can handle a growing player base and the increasing complexity of our simulated world, we have adopted a stateless architecture comprised of containerized services. This allows us to scale horizontally and deploy new features independently with predictable performance characteristics.

**Facilitating Extensibility and Modularity:** We believe that a highly modular system is crucial for long-term maintainability and the ability to continuously enrich the game world over the life of the project. The most engaging worlds are those in a continuous state of intentional evolution, where new features, mechanics, and content can be added without disrupting the existing experience.

## Core Architecture

The World Server serves as the single source of truth for our game universe, implementing a high-performance, transactional processing pipeline for all world mutations. As the core simulation engine, it manages the entire entity lifecycle while maintaining world consistency across a horizontally scalable deployment. World mutations take place in a pure, deterministic execution context, ensuring that all state changes are predictable and reproducible.

### HTTP Batch Command Processing

The World Server exposes an HTTP endpoint `POST /commands` that accepts both individual commands and **batches of commands**:

```typescript
// Single command
POST /commands
{ "type": "MOVE", "actor": "ch:player-1", "args": { "direction": "north" } }

// Batch of commands
POST /commands
[
  { "type": "MOVE", "actor": "ch:player-1", "args": { "direction": "north" } },
  { "type": "ATTACK", "actor": "ch:player-2", "args": { "target": "ch:orc-1" } },
  { "type": "CAST_SPELL", "actor": "ch:wizard", "args": { "spell": "fireball" } },
  { "type": "TRADE", "actor": "ch:player-3", "args": { "with": "ch:merchant" } }
]
```

**Batch processing maintains the same 3 round-trip guarantee**: All commands in a batch are processed sequentially through the pipeline using a single mega world projection that satisfies the data requirements for all commands, then committed atomically in one transaction.

### Database Design: Single-Table with Perfect Batching

All world state persists in a single PostgreSQL table designed for maximum batching efficiency:

```sql
CREATE TABLE world_state (
  pk VARCHAR NOT NULL,     -- Partition key: 'ch:<guid>' | 'pl:<name>'
  sk VARCHAR NOT NULL,     -- Sort key: 'base' | 'vitals' | 'inventory' | 'skills'
  data JSONB NOT NULL,     -- All entity data
  version INTEGER DEFAULT 1,
  PRIMARY KEY (pk, sk)
);
```

**Examples:**
```typescript
// Character data distributed across aspects
pk: 'ch:player-123',  sk: 'base'      // Name, location, basic stats
pk: 'ch:player-123',  sk: 'vitals'    // Health, mana, conditions
pk: 'ch:player-123',  sk: 'inventory' // Items, equipment
pk: 'ch:player-123',  sk: 'skills'    // Abilities, experience

// Place data distributed across aspects
pk: 'pl:tavern',      sk: 'base'      // Description, exits
pk: 'pl:tavern',      sk: 'entities'  // Present characters/NPCs
pk: 'pl:tavern',      sk: 'memories'  // Historical events
```

This design enables **perfect batching** - any combination of entity aspects can be loaded in a single database query using PostgreSQL's `IN` clause on the composite primary key.

### Dotpath JSONB Structure: Solving Write Contention

A critical architectural decision was made to address PostgreSQL's JSONB merge behavior, which creates write contention when multiple operations target overlapping object paths. When two updates modify the same JSONB object with overlapping key paths, the last update wins, potentially losing data from concurrent operations.

**The Problem: JSONB Merge Conflicts**
```typescript
// Traditional nested JSONB structure (problematic)
{
  "stats": {
    "strength": 15,
    "dexterity": 12,
    "intelligence": 10
  },
  "inventory": {
    "items": {
      "sword": 1,
      "potion": 3
    }
  }
}

// Concurrent updates to the same object cause conflicts:
// Update 1: SET data = jsonb_set(data, '{stats, strength}', '16')
// Update 2: SET data = jsonb_set(data, '{stats, dexterity}', '13')
// Result: Last update wins, first update is lost
```

**Our Solution: Flat Dotpath Keys**
```typescript
// Flat structure with dot-notation keys eliminates conflicts
{
  "stats.strength": 15,
  "stats.dexterity": 12,
  "stats.intelligence": 10,
  "inventory.items.sword": 1,
  "inventory.items.potion": 3,
  "vitals.health": 100,
  "vitals.mana": 50,
  "location.current": "tavern",
  "location.previous": "forest"
}
```

**Benefits of the Dotpath Approach:**
- **Perfect Concurrency**: Each dotpath key is independent, eliminating merge conflicts
- **Atomic Field Updates**: Multiple field updates can occur simultaneously without interference
- **Efficient Storage**: Only changed fields require updates, reducing write amplification
- **Clear Semantics**: Each dotpath represents a distinct data element with no ambiguity

**Trade-offs Accepted:**
- **No JSONB Queries**: We never query into the JSONB column structure
- **Application-Level Reconstruction**: Objects are reconstructed in memory when needed
- **Simplified Query Patterns**: All queries are primary key lookups only

This design choice enables our lock-free concurrency model and perfect batching capabilities, as each dotpath can be updated independently without conflict, regardless of the number of concurrent operations.

### Lock-Free Concurrency Control

We achieve high concurrency without traditional locking through **atomic JSONB partial updates with conditionals**:

```typescript
// Multiple players competing for the same item
await tx.execute(sql`
  UPDATE world_state
  SET data = jsonb_set(data, '{inventory,sword}', '1')
  WHERE pk = 'ch:player-123' AND sk = 'base'
    AND (data->'gold')::int >= 100  -- Conditional: can afford
`);

await tx.execute(sql`
  UPDATE world_state
  SET data = data - 'sword'
  WHERE pk = 'pl:tavern' AND sk = 'items'
    AND data ? 'sword'  -- Conditional: item exists
`);
```

**Key Principles:**
- **Flat JSONB structure**: Dotpath keys eliminate merge conflicts entirely
- **Conditional updates**: Business logic encoded as SQL conditions
- **Atomic transactions**: All related updates succeed or fail together
- **Natural retries**: Failed commands can be safely retried

This approach eliminates deadlocks while providing strong consistency guarantees through PostgreSQL's ACID properties.

### XMPP Communication Layer

The World Server operates as a stateless XMPP client with a canonical JID, functioning as an intelligent orchestrator rather than a passive message router. Player characters and key interactive NPCs are modeled as logical XMPP clients with unique JIDs, allowing asynchronous and independent communication. However, not every in-game entity receives its own JID—for performance and scalability reasons, especially in the case of monsters, shared processes handle control and communication.

XMPP provides us with essential messaging primitives that would otherwise require significant engineering investment:
- **Presence**: Track the presence and availability of entities in the world
- **Message Routing**: Send messages to specific entities or groups, enabling targeted communication
- **Pub-Sub**: Publish and subscribe to events for efficient communication of state changes
- **Multi-User Chat (MUC)**: Create and manage chat rooms representing different areas of the game world
- **Delayed Delivery**: Send messages for later delivery, enabling asynchronous communication between entities

### Reducer-Based State Management

Our architecture embraces reducers as the primary pattern for state transformation, creating consistent, predictable data flow throughout the system:

- **Pipeline Stages as Reducers**: Each stage transforms the execution context immutably
- **Entity Loaders with Reducers**: Data loading operations use reducers to update world state
- **Game Logic as Pure Reducers**: Core game mechanics are implemented as pure functions
- **Consistent Pattern**: `(State, Input) => New State` throughout the entire codebase

This approach provides numerous benefits: predictable unidirectional data flow, easier debugging and testing, better separation of concerns, and functional composition to build complex behavior from simple parts.

### Entity Loading Strategy

We use a DataLoader pattern with reducers to efficiently load entities and update world state:

- **Perfect Batching**: Multiple entity requests are batched into single database queries using composite key lookups
- **Automatic Deduplication**: DataLoader caching eliminates redundant loads within request scope
- **Cross-Stage Optimization**: Same DataLoader instances flow through pipeline stages, providing automatic caching
- **Parallel Loading**: All entities are loaded in parallel before applying reducers
- **Immutable Updates**: Loaded entities are incorporated into world state via pure reducers

This approach significantly improves performance while maintaining our functional architecture.

## Command Processing Pipeline: 3 Round-Trip Guarantee

Every world interaction flows through a deterministic five-stage pipeline with a **guaranteed maximum of 3 database round-trips** regardless of command complexity. Each stage is implemented as a Directed Acyclic Graph (DAG) of specialized handlers.

### Protocol Requirements

All Intents and Commands MUST include:
1. `actor: CharacterURN` - The entity initiating the action
2. `location: PlaceURN` - The Place where the action originates

This requirement enables efficient processing by providing critical context up front, eliminating the need for additional round-trips to discover basic contextual information.

```typescript
// Example Intent with required fields
{
  "input": "give sword to Gandalf",
  "actor": "flux:char:pc:123",
  "location": "flux:place:tavern"
}

// Example Command with required fields
{
  "type": "TRADE",
  "actor": "flux:char:pc:123",
  "location": "flux:place:tavern",
  "args": {
    "item": "flux:item:weapon:sword:1",
    "target": "flux:char:pc:gandalf:42"
  }
}
```

### The 3 Round-Trip Guarantee

1. **Round-Trip 1 (Negotiation)**: *Optional* - Only if input contains raw Intents
   ```typescript
   // Since location is known, we can load all needed context in parallel
   const worldData = await entityLoader.loadMany([
     ['pl:tavern', 'entities'],  // To resolve "Gandalf"
     ['ch:pc:123', 'inventory']  // To resolve "sword"
   ]);
   ```

2. **Round-Trip 2 (Contextualization)**: *Always* - Batch load world projection for all commands
   ```typescript
   // Load complete world projection in one query
   const worldData = await entityLoader.loadMany([
     ['ch:pc:123', 'base'], ['ch:pc:123', 'vitals'],
     ['ch:pc:gandalf', 'base'], ['ch:pc:gandalf', 'inventory'],
     ['pl:tavern', 'trade_rules']
   ]);
   ```

3. **Round-Trip 3 (Actuation)**: *Always* - Atomic batch write of all mutations
   ```typescript
   await db.transaction(async tx => {
     await Promise.all(commandSideEffects.map(effect =>
       tx.execute(buildAtomicUpdate(effect))
     ));
   });
   ```

### Stage Details

#### 1. Negotiation (0-1 Round-Trips)
- **Purpose:** Transform player "intents" (like text commands, XMPP stanzas, or ambiguous instructions) into canonical Command objects
- **Implementation:** Effectful handlers that may need to load world state to resolve ambiguous references
- **Output:** Well-formed Command
- **Key Point:** This stage is skipped entirely when the pipeline receives a well-formed Command as input (e.g., from HTTP/JSON APIs or structured client interfaces)

#### 2. Contextualization (1 Round-Trip)
- **Purpose:** Assemble the complete execution context required for command processing using perfect batching
- **Implementation:** Effectful handlers that batch-fetch all relevant world state from distributed storage
- **Output:** Enriched Command context with complete world projection
- **Optimization:** DataLoader automatic deduplication eliminates redundant loads from Negotiation stage

#### 3. Transformation (0 Round-Trips)
- **Purpose:** Execute core game logic in a pure, deterministic environment
- **Implementation:** Pure handlers that compute state transitions without side effects and declare emergent events through a formal event schema
- **Output:** State delta objects and event declarations

At its core, each game logic handler implements a pure, deterministic reducer function:

$f : (W, C) \rightarrow (W', E)$

Where:
- $W$ represents a projection of world state
- $C$ represents the command to be processed
- $W'$ represents a new world state projection
- $E$ represents the set of emergent events generated

**Keeping Transformation Handlers Pure:** We deliberately keep handlers in this stage as pure and focused as possible. These handlers are primarily responsible for the deterministic transformation of world state in response to commands. We've consciously moved side effects, external interactions, and complex conditional logic out of these core functions because pure functions are incredibly easy to test. Given the same input (current world state and a command), they always produce the same output (new world state and declared events/side effects). We can literally develop game features in a browser with no internet connection — and that's exactly what we do.

#### 4. Planning (0 Round-Trips)
- **Purpose:** Analyze both emergent events and world state changes to determine necessary side effects
- **Implementation:** Pure handlers that translate emergent events into concrete side effect declarations, examine world mutations to identify required persistence and notification needs, coordinate related side effects to optimize execution, and determine appropriate priorities and dependencies between effects
- **Input:** Emergent events declared during Transformation stage and world state deltas from Transformation stage
- **Output:** Complete set of side effect declarations for execution

The Planning stage serves as a critical boundary between pure domain logic and effectful operations. By examining both what happened (events) and what changed (state mutations), it creates a comprehensive plan for how these changes should manifest in the outside world. As such, this stage completely insulates game logic from infrastructure concerns.

#### 5. Actuation (1 Round-Trip)
- **Purpose:** Apply declared side effects to external services and infrastructure using atomic batch operations
- **Implementation:** Effectful handlers that execute all database writes in a single transaction plus coordinate XMPP message delivery
- **Output:** World state mutations committed atomically, XMPP stanzas delivered to clients

**Atomic Batch Strategy:** All database writes from a single command are committed in one transaction using conditional JSONB partial updates. This approach ensures consistency while enabling high concurrency through lock-free updates.

## Performance Characteristics

### Why 3 Round-Trips is Remarkable

Most MUD architectures exhibit O(n) database round-trips where n = number of entities or systems involved:

```typescript
// Typical MUD command processing
await checkPlayerExists(playerId);           // Round-trip 1
await getCurrentRoom(player.location);       // Round-trip 2
await getVisibleEntities(roomId);           // Round-trip 3
await checkInventory(playerId);             // Round-trip 4
await updatePlayerLocation(playerId, newRoom); // Round-trip 5
await updateRoomOccupants(oldRoom, newRoom);   // Round-trip 6
// ... complexity grows with command scope
```

**Our architecture achieves O(1) round-trips with O(log n) query performance** - a simple "look" command and a complex "cast fireball affecting 20 entities" both complete in exactly 3 round-trips, with individual queries scaling logarithmically due to PostgreSQL's B-tree index performance.

**Batch processing maintains the same guarantee** - processing 1 command or 1000 commands requires identical database access patterns. This is possible because:

- **PostgreSQL B-tree Performance**: Primary key lookups scale at O(log n), which remains exceptionally fast even at massive scale due to high branching factors
- **Perfect Batching Design**: Our `(pk, sk)` table structure enables any combination of entity aspects to be loaded in a single query
- **Atomic Transaction Capability**: PostgreSQL can handle large atomic transactions with thousands of JSONB partial updates efficiently

### Scalability Implications

- **Constant Round-Trip Guarantee**: Database access patterns remain fixed regardless of command complexity or batch size
- **Logarithmic Query Scaling**: PostgreSQL's B-tree primary key lookups provide O(log n) performance - exceptional scaling for database operations
- **High Concurrency**: Lock-free atomic updates eliminate contention bottlenecks
- **Predictable Performance**: Network latency dominates over query execution time, making batch operations dramatically faster
- **Practical Near-Constant Performance**: The logarithmic curve is so shallow (due to high B-tree branching factors) that performance feels constant for realistic game scales
- **Measurable Guarantees**: Easy to monitor and verify in production

**Real-World Impact**: A guild raid with 50 players executing simultaneous combat actions can be processed with the same database access pattern as a single player movement command - 3 round-trips total, with query time scaling logarithmically rather than linearly with complexity.

This pipeline architecture enables complex emergent behaviors while maintaining deterministic execution, transactional integrity, and linear scalability as player concurrency increases.

## Living World Simulation

In order for our world to feel alive, we need systems that simulate the passage of time and its effects on the world. This is achieved through specialized Simulation Servers that operate as independent agents within our distributed architecture.

### Simulation Server Architecture

A Simulation Server is a specialized backend microservice that connects to the World Server on a well-known JID. It issues commands to the World Server on behalf of the entities it simulates and subscribes to the XMPP stream to receive events relevant to those entities. This allows each Simulation Server to react to changes in the world and issue commands in response, creating dynamic feedback loops that drive emergent behavior.

Each simulation server maintains the illusion that every entity it controls is a thinking, present agent—while efficiently concentrating decision logic into manageable processes. Actions generated by simulated entities are emitted into the same event stream as player actions, maintaining consistency and supporting emergent interactions.

### Simulation Services

**WeatherSimulationService** emits weather updates for Places based on environmental metadata (biome tags, altitude), influences gameplay by affecting visibility, movement, and combat outcomes, and triggers events such as `/event/weather/changed` which other subscribers can react to.

**PlaceService** periodically restores Place-level features such as natural resources, terrain integrity, and local flora. It can reflect seasonal or magical regeneration tied to the passage of world time, helps maintain ecological balance and playability of key areas, and periodically regenerates descriptions of Places via LLM prompts that include information about the place and recent events.

**InvasionService** drives large-scale conflict events such as monster raids or faction wars, spawns coordinated hostile NPCs and coordinates their behavior across multiple Places, and emits events like `/event/invasion/started`, allowing both players and NPC systems to react dynamically.

**MonsterSimulationService** controls the behavior of vast numbers of monster entities across the World, emitting monster actions as if they were independent agents while operating efficiently as a centralized decision system on a single XMPP JID.

### Scalability and Deployment

The World Server and all Simulation Server processes are stateless and containerized. All persistent state lives in a centralized PostgreSQL database and Redis cache. Scaling out is as simple as spinning up new containers in an autoscaling environment.

For monster simulation specifically, multiple instances can be spun up to handle load, with each managing a subset of monster entities. The control plane coordinates assignment of monster populations to simulation processes based on Place geography, player density, or event activity.

### Concurrency and Consistency

- **Atomic JSONB Partial Updates**: We leverage PostgreSQL's JSONB capabilities to perform atomic updates on entity attributes, allowing concurrent modifications without locking
- **Conditional Updates**: Business logic is encoded as SQL conditions, providing natural conflict resolution
- **Single Transaction Guarantee**: All world mutations from a single command are committed atomically. If any part fails, the entire command is rolled back, guaranteeing world consistency
- **Lock-Free Architecture**: No traditional locking eliminates deadlock possibilities while maximizing concurrency

## Appendix

### XMPP Use Cases

#### Player Movement

```xml
<!-- Player sends movement intent command -->
<message to="server@fabric.flux.io" type="chat">
  <flux:command xmlns:flux="urn:flux:commands" id="dDtYEr7BbHQxMInfgpdG6WH1yRNZ101a">
    <!CDATA[
      { "input": "go north" }
    ]>
  </flux:command>
</message>

<!-- World Server processes command and initiates room transition -->

<!-- 1. Player leaves current room -->
<presence from="flux.char.pc.9b89a4c1-578d-40b3-8eca-b30374472a0c@fabric.flux.io/client"
          to="tavern@muc.fabric.flux.io/nickname"
          type="unavailable">
  <flux:trace id="dDtYEr7BbHQxMInfgpdG6WH1yRNZ101a" />
  <flux:exit direction="north" />
</presence>

<!-- 2. Other occupants in old room receive departure notification -->
<message from="server@muc.fabric.flux.io"
         to="flux.place.fenwatch.town.square@muc.fabric.flux.io">
  <flux:trace id="dDtYEr7BbHQxMInfgpdG6WH1yRNZ101a" />
  <flux:event xmlns:flux="urn:flux:events" type="ENTITY_MOVED">
    <flux:entity id="player@fabric.flux.io/resource" />
    <flux:direction>north</flux:direction>
  </flux:event>
</message>

<!-- 3. Player joins new room -->
<presence from="flux.char.pc.b940c477-3583-4af6-a84d-f387e063f79a@fabric.flux.io/resource"
          to="flux.place.fenwatch.tavern@muc.fabric.flux.io/nickname">
  <flux:trace id="dDtYEr7BbHQxMInfgpdG6WH1yRNZ101a" />
  <flux:enter direction="south" />
</presence>

<!-- 4. Other occupants in new room receive arrival notification -->
<message from="town-square@muc.fabric.flux.io/system"
         to="town-square@muc.fabric.flux.io">
  <flux:event xmlns:flux="urn:flux:events" type="ENTITY_MOVED">
  <flux:trace id="dDtYEr7BbHQxMInfgpdG6WH1yRNZ101a" />
    <flux:entity id="player@fabric.flux.io/resource" />
    <flux:direction>south</flux:direction>
  </flux:event>
</message>
```
