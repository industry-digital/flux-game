# Flux Simulation Project: Architectural Overview

## Introduction

This document outlines the architectural design of our multiplayer text-based game (MUD), with a central emphasis on emergent gameplay.

A MUD (Multi-User Dungeon) is a text-based virtual world where players interact with the environment and each other through written commands, receiving rich narrative descriptions in return; they are the earliest form of online multiplayer games and remain compelling due to their focus on imagination, narrative depth, and complex world simulation.

Our goal is to foster rich, unscripted experiences that arise from the interplay of simulation systems, player actions, and AI-driven world elements. The architecture is deliberately structured to encourage surprising outcomes and dynamic narrative developments—where the world feels alive not because it is prewritten, but because it is reactive, systemic, and full of possibility.

## Executive Summary

Our MUD architecture is built on four key pillars:

1. **Emergent Gameplay** - Complex behavior emerges from simple systems interacting through taxonomic relationships
2. **XMPP-Based Communication** - Using a proven messaging protocol as a spatial simulation framework
3. **Reducer-Based Processing** - Pure, deterministic state transformations with clear separation of concerns
4. **Distributed Simulation** - Independent services that create a living world through autonomous agents

The system uses a five-stage processing pipeline for all world interactions, with a strict separation between pure game logic and side effects. All interactions flow through this pipeline, ensuring consistent behavior and enabling complex emergent phenomena to arise organically from the interaction of simple systems.

## Design Philosophy

### Emergent Gameplay as First Principle

When we talk about "emergence," we are referring to game outcomes or phenomena that are not explicitly scripted but instead arise from the complex interplay of our data-driven world, the independent actions of entities within it, and the dynamic content generated by AI. These behaviors can surprise even the creators of the game, as they are not directly programmed but rather emerge from the interactions of simpler components.

At the heart of our design is the desire to foster emergent behaviors that arise from the interactions of players, NPCs, and the environment. We want to create a world where players can discover unexpected new strategies, tactics, and stories through their actions and interactions with others. It's not our job as creators of the world to tell the player everything about it. It is up to the player to discover the world and its secrets.

In our architecture, emergence is primarily driven by:

**Data-Driven Design with Rich Taxonomic Semantics:** Our game world is built upon a foundation of richly structured data, where entities and their properties are defined and categorized according to a clearly defined taxonomy. This deep semantic layering allows for a multitude of potential interactions based on the inherent characteristics and relationships encoded within the entity data model itself. The game's systems are designed to react to these data points in consistent ways, leading to complex outcomes as different data sets interact.

*Example*: A creature with the taxonomic classification `flux:type:monster:elemental:fire` will react differently to an environment tagged `flux:climate:wet` than one tagged `flux:climate:arid`, potentially leading to unexpected combat behaviors or environmental effects.

**Interplay of Independent Entities:** Players, NPCs, environmental simulations, and even AI-driven content generators operate as independent agents within the shared world. Their actions are not centrally orchestrated in a rigid, linear fashion. Instead, each entity reacts to the current world state based on its own rules and goals. The simultaneous and often uncoordinated actions of these independent entities can lead to complex chains of events and surprising outcomes.

*Example*: A player's attempt to trade with a merchant (an independent NPC with its own economic motivations) in a town affected by a simulated economic downturn might lead to unexpected prices or even a refusal to trade, creating emergent economic challenges and opportunities.

**LLM-Driven Dynamic Content:** Our integration of modern large language models allows for the generation of dynamic content, such as entity descriptions, NPC dialogue, and even quest elements, that can react in novel and contextually relevant ways to the current state of the world and player actions. This AI-driven responsiveness introduces an element of unpredictability and can lead to emergent narrative possibilities and surprising interactions that were not explicitly authored.

*Example*: An NPC whose initial description was LLM-generated might react to a player character's reputation (a data point tracked by the system) in a way that reflects that reputation in their dialogue, creating an emergent social interaction that feels personalized and dynamic.

### Case Study: The Wedding Massacre

Imagine a player hosting an elaborate wedding in Oakhollow's town square (`flux:event:social:wedding`).

A guard confronts a troublemaker at the ceremony, landing a critical hit that severs the infiltrator's hand (`flux:anatomy:hand`). The severed hand drops a napalm grenade, which explodes.

This creates a precise taxonomic convergence that would normally never occur:
- A sacred union (`flux:place:ceremonial`) becomes a place of bloodshed
- The napalm grenade's specific damage type (`flux:damage:unholy:fire`) interacts with the wedding altar's material (`flux:material:blessed:wood`)
- All occurring during the dark moon (`flux:time:darkmoon`)

When unholy fire burns blessed wood during a dark moon, the World Server recognizes this rare pattern and triggers `flux:event:invasion:demonic` - powerful demons materialize and attack the wedding guests.

No designer explicitly programmed this specific chain of events. Instead, the underlying simulation evaluates taxonomic patterns that arise naturally from interactions between entities, materials, and world states. The same wedding disrupted by a regular explosive would have ended with just structural damage - demonstrating how emergence creates dynamic experiences from overlapping rule systems.

### Supporting Architectural Principles

**XMPP as a Spatial Simulation Protocol:** We use the Extensible Messaging and Presence Protocol (XMPP) not just as a communication fabric, but as a spatial simulation protocol. Each `Place` in the game world is modeled as a Multi-User Chat (MUC) room, and the movement of entities through space is mirrored by their traversal through MUCs. This choice gives us sophisticated messaging primitives for free while mapping naturally to MUD spatial concepts.

**Prioritizing Scalability and Performance:** To ensure the game can handle a growing player base and the increasing complexity of our simulated world, we have adopted a stateless architecture comprised of containerized services. This allows us to scale horizontally and deploy new features independently with predictable performance characteristics.

**Facilitating Extensibility and Modularity:** We believe that a highly modular system is crucial for long-term maintainability and the ability to continuously enrich the game world over the life of the project. The most engaging worlds are those in a continuous state of intentional evolution, where new features, mechanics, and content can be added without disrupting the existing experience.

## Core Architecture

The World Server serves as the single source of truth for our game universe, implementing a high-performance, transactional processing pipeline for all world mutations. As the core simulation engine, it manages the entire entity lifecycle while maintaining world consistency across a horizontally scalable deployment. World mutations take place in a pure, deterministic execution context, ensuring that all state changes are predictable and reproducible.

### XMPP Communication Layer

The World Server operates as a stateless XMPP client with a canonical JID, functioning as an intelligent orchestrator rather than a passive message router. Player characters and key interactive NPCs are modeled as logical XMPP clients with unique JIDs, allowing asynchronous and independent communication. However, not every in-game entity receives its own JID—for performance and scalability reasons, especially in the case of monsters, shared processes handle control and communication.

XMPP provides us with essential messaging primitives that would otherwise require significant engineering investment:
- **Presence**: Track the presence and availability of entities in the world
- **Message Routing**: Send messages to specific entities or groups, enabling targeted communication
- **Pub-Sub**: Publish and subscribe to events for efficient communication of state changes
- **Multi-User Chat (MUC)**: Create and manage chat rooms representing different areas of the game world
- **Delayed Delivery**: Send messages for later delivery, enabling asynchronous communication between entities

### Reducer-Based State Management

Our architecture embraces reducers as the primary pattern for state transformation, creating consistent, predictable data flow throughout the system:

- **Pipeline Stages as Reducers**: Each stage transforms the execution context immutably
- **Entity Loaders with Reducers**: Data loading operations use reducers to update world state
- **Game Logic as Pure Reducers**: Core game mechanics are implemented as pure functions
- **Consistent Pattern**: `(State, Input) => New State` throughout the entire codebase

This approach provides numerous benefits: predictable unidirectional data flow, easier debugging and testing, better separation of concerns, and functional composition to build complex behavior from simple parts.

### Entity Loading Strategy

We use a DataLoader pattern with reducers to efficiently load entities and update world state:

- **Batching**: Multiple entity requests are batched into single database queries
- **Caching**: Repeated requests for the same entity are returned from cache
- **Parallel Loading**: All entities are loaded in parallel before applying reducers
- **Immutable Updates**: Loaded entities are incorporated into world state via pure reducers

This approach significantly improves performance while maintaining our functional architecture.

## Command Processing Pipeline

Every world interaction flows through a deterministic five-stage pipeline, where each stage is implemented as a Directed Acyclic Graph (DAG) of specialized handlers. This approach decouples concerns while maintaining transactional integrity throughout the entire processing lifecycle.

```mermaid
flowchart LR
    A[Incoming XMPP Intent or Command] --> B[Negotiation DAG]
    B --> C[Contextualization DAG]
    C --> D[Transformation DAG]
    D --> E[Planning DAG]
    E --> F[Actuation DAG]

    classDef effectful fill:#f96,stroke:#333,stroke-width:2px
    classDef pure fill:#9f6,stroke:#333,stroke-width:2px

    class B,C,F effectful
    class D,E pure
```

### 1. Negotiation
- **Purpose:** Transform player "intents" (like text commands, XMPP stanzas, or ambiguous instructions) into canonical Command objects
- **Implementation:** Effectful handlers that parse, interpret, disambiguate, and normalize incoming intents
- **Output:** Well-formed Command objects with authenticated actor context
- **Key Point:** This stage is skipped entirely when the pipeline receives a well-formed Command as input (e.g., from HTTP/JSON APIs or structured client interfaces)

### 2. Contextualization
- **Purpose:** Assemble the complete execution context required for command processing
- **Implementation:** Effectful handlers that fetch relevant world state from distributed storage
- **Output:** Enriched Command context with hydrated references to actors, targets, and environment

### 3. Transformation
- **Purpose:** Execute core game logic in a pure, deterministic environment
- **Implementation:** Pure handlers that compute state transitions without side effects and declare emergent events through a formal event schema
- **Output:** State delta objects and event declarations

At its core, each GameLogicHandler implements a pure, deterministic reducer function:

$f : (W, C) \rightarrow (W', E)$

Where:
- $W$ represents a projection of world state
- $C$ represents the command to be processed
- $W'$ represents a new world state projection
- $E$ represents the set of emergent events generated

**Keeping Transformation Handlers Pure:** We deliberately keep handlers in this stage as pure and focused as possible. These handlers are primarily responsible for the deterministic transformation of world state in response to commands. We've consciously moved side effects, external interactions, and complex conditional logic out of these core functions because pure functions are incredibly easy to test. Given the same input (current world state and a command), they always produce the same output (new world state and declared events/side effects). We can literally develop game features in a browser with no internet connection — and that's exactly what we do.

### 4. Planning
- **Purpose:** Analyze both emergent events and world state changes to determine necessary side effects
- **Implementation:** Pure handlers that translate emergent events into concrete side effect declarations, examine world mutations to identify required persistence and notification needs, coordinate related side effects to optimize execution, and determine appropriate priorities and dependencies between effects
- **Input:** Emergent events declared during Transformation stage and world state deltas from Transformation stage
- **Output:** Complete set of side effect declarations for execution

The Planning stage serves as a critical boundary between pure domain logic and effectful operations. By examining both what happened (events) and what changed (state mutations), it creates a comprehensive plan for how these changes should manifest in the outside world. As such, this stage completely insulates game logic from infrastructure concerns.

### 5. Actuation
- **Purpose:** Apply declared side effects to external services and infrastructure
- **Implementation:** Effectful handlers that interact with persistence layers and external services using transactional guarantees
- **Output:** World state mutations committed to database in a single transaction, XMPP stanzas sent to clients, command transactions routed to Kafka

**Database Transaction Strategy:** All database writes from a single command are committed atomically in one database transaction. We employ atomic partial updates to JSONB columns (particularly for entity attributes) to reduce write contention and enable high-concurrency modifications to the same entities. This approach ensures consistency while maintaining performance under load.

This pipeline architecture enables complex emergent behaviors while maintaining deterministic execution, transactional integrity, and linear scalability as player concurrency increases.

## Living World Simulation

In order for our world to feel alive, we need systems that simulate the passage of time and its effects on the world. This is achieved through specialized Simulation Servers that operate as independent agents within our distributed architecture.

### Simulation Server Architecture

A Simulation Server is a specialized backend microservice that connects to the World Server on a well-known JID. It issues commands to the World Server on behalf of the entities it simulates and subscribes to the XMPP stream to receive events relevant to those entities. This allows each Simulation Server to react to changes in the world and issue commands in response, creating dynamic feedback loops that drive emergent behavior.

Each simulation server maintains the illusion that every entity it controls is a thinking, present agent—while efficiently concentrating decision logic into manageable processes. Actions generated by simulated entities are emitted into the same event stream as player actions, maintaining consistency and supporting emergent interactions.

### Simulation Services

**WeatherSimulationService** emits weather updates for Places based on environmental metadata (biome tags, altitude), influences gameplay by affecting visibility, movement, and combat outcomes, and triggers events such as `/event/weather/changed` which other subscribers can react to.

**PlaceService** periodically restores Place-level features such as natural resources, terrain integrity, and local flora. It can reflect seasonal or magical regeneration tied to the passage of world time, helps maintain ecological balance and playability of key areas, and periodically regenerates descriptions of Places via LLM prompts that include information about the place and recent events.

**InvasionService** drives large-scale conflict events such as monster raids or faction wars, spawns coordinated hostile NPCs and coordinates their behavior across multiple Places, and emits events like `/event/invasion/started`, allowing both players and NPC systems to react dynamically.

**MonsterSimulationService** controls the behavior of vast numbers of monster entities across the World, emitting monster actions as if they were independent agents while operating efficiently as a centralized decision system on a single XMPP JID.

### Scalability and Deployment

The World Server and all Simulation Server processes are stateless and containerized. All persistent state lives in a centralized PostgreSQL database and Redis cache. Scaling out is as simple as spinning up new containers in an autoscaling environment.

For monster simulation specifically, multiple instances can be spun up to handle load, with each managing a subset of monster entities. The control plane coordinates assignment of monster populations to simulation processes based on Place geography, player density, or event activity.

### Concurrency and Consistency

Our backend ensures world coherence using a blend of real-time and eventual consistency strategies:

- **Optimistic Concurrency**: World state updates use versioning to prevent race conditions
- **Distributed Locks**: Redis-based locks are employed for operations that must be exclusive (e.g., looting)
- **Ordered Event Stream**: Within a single XMPP stream, stanzas are processed in order. World mutations are serialized to preserve causal integrity

These choices balance responsiveness with the guarantees needed for a shared world simulation. Each simulation service respects this model by issuing commands to the World Server and reacting to events the same way player characters would, maintaining architectural consistency while enabling rich autonomous behavior.

## Appendix

### XMPP Use Cases

#### Player Movement

```xml
<!-- Player sends movement intent command -->
<message to="server@fabric.flux.io" type="chat">
  <flux:command xmlns:flux="urn:flux:commands" id="dDtYEr7BbHQxMInfgpdG6WH1yRNZ101a">
    <!CDATA[
      { "input": "go north" }
    ]>
  </flux:command>
</message>

<!-- World Server processes command and initiates room transition -->

<!-- 1. Player leaves current room -->
<presence from="flux.char.pc.9b89a4c1-578d-40b3-8eca-b30374472a0c@fabric.flux.io/client"
          to="tavern@muc.fabric.flux.io/nickname"
          type="unavailable">
  <flux:trace id="dDtYEr7BbHQxMInfgpdG6WH1yRNZ101a" />
  <flux:exit direction="north" />
</presence>

<!-- 2. Other occupants in old room receive departure notification -->
<message from="server@muc.fabric.flux.io"
         to="flux.place.fenwatch.town.square@muc.fabric.flux.io">
  <flux:trace id="dDtYEr7BbHQxMInfgpdG6WH1yRNZ101a" />
  <flux:event xmlns:flux="urn:flux:events" type="ENTITY_MOVED">
    <flux:entity id="player@fabric.flux.io/resource" />
    <flux:direction>north</flux:direction>
  </flux:event>
</message>

<!-- 3. Player joins new room -->
<presence from="flux.char.pc.b940c477-3583-4af6-a84d-f387e063f79a@fabric.flux.io/resource"
          to="flux.place.fenwatch.tavern@muc.fabric.flux.io/nickname">
  <flux:trace id="dDtYEr7BbHQxMInfgpdG6WH1yRNZ101a" />
  <flux:enter direction="south" />
</presence>

<!-- 4. Other occupants in new room receive arrival notification -->
<message from="town-square@muc.fabric.flux.io/system"
         to="town-square@muc.fabric.flux.io">
  <flux:event xmlns:flux="urn:flux:events" type="ENTITY_MOVED">
  <flux:trace id="dDtYEr7BbHQxMInfgpdG6WH1yRNZ101a" />
    <flux:entity id="player@fabric.flux.io/resource" />
    <flux:direction>south</flux:direction>
  </flux:event>
</message>
```
