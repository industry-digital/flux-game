# Weather Description System

## ğŸŒ¤ï¸ **Overview**

The Weather Description System generates human-readable descriptions of atmospheric changes using a functional reducer pipeline. Instead of describing static weather states, it focuses on meaningful transitions that affect player experience.

## ğŸš¨ **The Combinatorial Explosion Problem**

### **How We Got Here**
When designing a system to describe atmospheric changes, we initially considered modeling individual weather phenomena separately:

- **Solar geometry** - sunrise, sunset, solar angle changes
- **Cloud dynamics** - gathering, clearing, density changes
- **Light interactions** - PPFD changes, scattering effects
- **Atmospheric conditions** - humidity, pressure, seasonal effects
- **Precipitation** - rain starting/stopping, intensity changes

### **The Mathematical Reality**
With N independent phenomena, we face **2^N possible combinations**:

```typescript
// Just 5 phenomena = 32 combinations
const phenomena = [
  'solar-transition',    // sunrise, sunset, solar-noon
  'cloud-change',        // gathering, clearing, stable
  'light-change',        // brightening, dimming, stable
  'atmospheric-shift',   // humidity, pressure changes
  'precipitation-event'  // rain, snow, clearing
];

// Possible combinations: 2^5 = 32
// Example problematic combinations:
// - Sunrise + clouds gathering + light dimming + high pressure + rain starting
// - Sunset + clouds clearing + light brightening + low humidity + snow stopping
// - Solar noon + stable clouds + stable light + pressure drop + no precipitation
```

### **Why This Doesn't Work**
1. **Template explosion** - Need to write descriptions for 32+ combinations
2. **Nonsensical combinations** - Many combinations don't make physical sense
3. **Maintenance nightmare** - Adding one phenomenon doubles the combinations
4. **Poor player experience** - Most combinations are uninteresting to players
5. **Diminishing returns** - 90% of combinations would rarely occur

### **The Insight**
Most combinations are either:
- **Physically impossible** - "bright sunshine during heavy storm"
- **Redundant** - "light brightening" + "clouds clearing" say the same thing
- **Uninteresting** - "stable conditions across all phenomena"
- **Too complex** - descriptions become unwieldy with many simultaneous changes

## ğŸ¯ **Core Philosophy**

### **Meaningful Transitions Only**
We solve the combinatorial explosion by identifying only atmospheric transitions that are meaningful to a human player:

- **Dramatic visibility changes** - affect what players can see/do
- **Weather events that signal change** - storms approaching/clearing
- **Time transitions with emotional weight** - dawn, dusk, golden hour
- **Atmospheric mood shifts** - eerie stillness, oppressive air, crisp clarity

This constrains us to ~15-20 meaningful scenarios instead of hundreds of theoretical combinations.

## ğŸ—ï¸ **Architecture**

### **Reducer Pipeline**
The `describeWeather` function internally uses this reducer pipeline:

```typescript
// Internal implementation - called by describeWeather
const describeWeatherChange = (prev: Weather, current: Weather): string => {
  const initialState: WeatherDescription = {
    narrative: [],
    context: {
      timeOfDay: getTimeOfDay(current.date),
      mood: 'neutral'
    },
    intensity: 0
  };

  const description = [
    applySolarGeometry,           // Sun angle, sunrise/sunset timing
    applyCloudCover,             // Cloud density effects on light
    applyAtmosphericScattering,  // Rayleigh/Mie scattering effects
    applySeasonalEffects,        // Seasonal light quality changes
    enhanceNarrative,            // Cross-phenomenon interactions
    renderFinalDescription       // Final composition
  ].reduce((acc, reducer) => reducer(acc, prev, current), initialState);

  return description.narrative.join(' ');
};

// Public API
export const describeWeather: Template<DescribeWeatherProps> = (props) => {
  if (!props.previous) return ''; // No change to describe
  return describeWeatherChange(props.previous, props.current);
};
```

### **Core Types**
```typescript
type WeatherDescription = {
  narrative: string[];           // Built up incrementally
  context: {
    timeOfDay: 'dawn' | 'day' | 'dusk' | 'night';
    timeTransition?: 'sunrise' | 'sunset' | 'deepening';
    cloudChange?: 'clearing' | 'gathering' | 'stable';
    lightChange?: 'brightening' | 'dimming' | 'stable';
    mood: 'peaceful' | 'dramatic' | 'ominous' | 'neutral';
  };
  intensity: number;             // 0-1, how dramatic the change is
};

type WeatherReducer = (
  acc: WeatherDescription,
  prev: Weather,
  current: Weather
) => WeatherDescription;
```

## ğŸ”§ **Reducer Functions**

### **Physical Phenomenon Reducers**
Each reducer models a specific physical process:

```typescript
const applySolarGeometry: WeatherReducer = (acc, prev, current) => {
  // Handle sun elevation angle, sunrise/sunset, solar noon effects
  const prevHour = prev.date.getHours();
  const currHour = current.date.getHours();

  if (prevHour < 6 && currHour >= 6) {
    return {
      ...acc,
      context: { ...acc.context, timeTransition: 'sunrise' },
      narrative: [...acc.narrative, 'Dawn breaks across the horizon'],
      intensity: Math.max(acc.intensity, 0.6)
    };
  }

  return acc;
};

const applyCloudCover: WeatherReducer = (acc, prev, current) => {
  // Handle how clouds interact with direct/diffuse light
  const cloudDelta = current.clouds - prev.clouds;

  if (cloudDelta > 30) {
    return {
      ...acc,
      context: { ...acc.context, cloudChange: 'gathering' },
      narrative: [...acc.narrative, 'as storm clouds gather overhead'],
      intensity: Math.max(acc.intensity, 0.4)
    };
  }

  return acc;
};
```

### **Enhancement Reducers**
Later reducers can rewrite or enhance earlier decisions:

```typescript
const enhanceNarrative: WeatherReducer = (acc, prev, current) => {
  // Look for meaningful combinations
  if (acc.context.timeTransition === 'sunrise' && acc.context.cloudChange === 'gathering') {
    // Replace fragments with enhanced version
    const enhanced = 'Dawn struggles to break through gathering storm clouds';
    return {
      ...acc,
      narrative: [...acc.narrative.slice(0, -2), enhanced]
    };
  }

  return acc;
};
```

## ğŸ¨ **Meaningful Atmospheric Transitions**

### **High-Impact Transitions**
1. **Dawn through storm clouds** - "Dawn struggles through heavy overcast"
2. **Sun breaks through** - "Sunlight bursts through, illuminating the landscape"
3. **Storm approaching** - "Dark clouds swallow the sun, bringing premature twilight"
4. **Golden hour** - "The setting sun bathes everything in honey-colored light"
5. **Twilight deepening** - "Twilight deepens into true darkness"

### **Atmospheric Mood Shifts**
1. **Eerie stillness** - "An oppressive calm settles over the land"
2. **Crisp clarity** - "Crystal-clear air makes distant mountains seem close"
3. **Thick atmosphere** - "The air grows heavy and humid"

### **Weather Event Signals**
1. **Storm building** - "Thunder rumbles in the distance"
2. **Storm breaking** - "The first fat raindrops begin to fall"
3. **Storm clearing** - "Storm clouds part, revealing patches of blue sky"

### **Precipitation Transitions**
Rain directly affects gameplay mechanics, making these transitions critical:

1. **Rain beginning** - "A light drizzle begins to fall from the gray sky"
2. **Rain intensifying** - "The gentle rain becomes a steady downpour"
3. **Heavy rain starting** - "Heavy drops drum against the ground with increasing intensity"
4. **Rain lessening** - "The downpour eases to a gentle patter"
5. **Rain stopping** - "The last raindrops fall as the clouds begin to part"
6. **Mist/fog forming** - "A fine mist rises from the wet ground"

## ğŸ“Š **Implementation Benefits**

### **Maintainability**
- **Pure functions** - Each reducer is testable in isolation
- **Single responsibility** - Each reducer handles one physical phenomenon
- **Composable** - Easy to reorder, add, or remove reducers
- **Clear naming** - Function names reflect physical processes

### **Extensibility**
Adding new weather phenomena requires only adding new reducers:
```typescript
const description = [
  applySolarGeometry,
  applyCloudCover,
  applyWindChanges,      // New!
  applyTemperatureShifts, // New!
  applyAurora,           // New!
  enhanceNarrative,
  renderFinalDescription
].reduce((acc, reducer) => reducer(acc, prev, current), initialState);
```

### **Flexibility**
- **Context-aware** - Later reducers see what earlier ones detected
- **Incremental** - Narrative builds up piece by piece
- **Rewritable** - Enhancement steps can completely rewrite earlier decisions

## ğŸš€ **Usage Examples**

### **Simple Time Transition**
```typescript
// Input: 5:45 AM â†’ 6:15 AM, clear skies
// Output: "Dawn breaks across the horizon, painting the sky in soft pastels."
```

### **Complex Interaction**
```typescript
// Input: Dawn + gathering storm clouds + dropping PPFD
// Output: "Dawn struggles to break through gathering storm clouds, casting an eerie gray light over the landscape."
```

### **Dramatic Weather Event**
```typescript
// Input: Midday + rapid cloud buildup + PPFD drops 80%
// Output: "Dark storm clouds suddenly swallow the sun, plunging the area into premature twilight."
```

## ğŸ¯ **Design Principles**

1. **Focus on Player Experience** - Only describe changes that matter to someone in this world
2. **Physical Accuracy** - Base descriptions on real atmospheric phenomena
3. **Narrative Weight** - Emphasize transitions with emotional or gameplay significance
4. **Compositional** - Build complex descriptions from simple, reusable parts
5. **Maintainable** - Keep reducers focused and pure for easy testing/modification
6. **Atmospheric Focus** - Describe the weather phenomena as experienced, not their gameplay consequences

### **Separation of Concerns**
The weather description system describes **what players perceive**, not **what happens mechanically**:

- âœ… **Good**: "Heavy rain drums against the ground"
- âŒ **Bad**: "Heavy rain forms puddles that slow movement"
- âœ… **Good**: "A thick fog rolls in, reducing visibility"
- âŒ **Bad**: "Fog appears, reducing your vision range to 2 tiles"

Let the game mechanics handle mechanical effects. The description system focuses on atmospheric immersion.

## ğŸ“ **Implementation Notes**

- **PPFD Integration** - Use PPFD values (0-2000 Î¼mol/mÂ²/s) to drive light-based descriptions
- **Time Sensitivity** - Factor in realistic sunrise/sunset times based on season/location
- **Weather Correlation** - Ensure cloud cover and PPFD changes are consistent
- **Intensity Scaling** - More dramatic changes get more elaborate descriptions
- **Fragment Quality** - Each narrative fragment should be a well-formed sentence component

## ğŸ“ **Implementation Location**

**All weather description system implementation must be placed in:**
```
game/src/template/weather/
```

### **Public API**
The weather directory exports a **single function** that the rest of the game uses:

```typescript
// game/src/template/weather/index.ts
export const describeWeather: Template<DescribeWeatherProps> = (props) => {
  // All reducer pipeline implementation happens here
  return describeWeatherChange(props.previous, props.current);
};
```

**Everything else is internal implementation.** The reducer pipeline, meaningful transitions, PPFD calculations - all of that supports this one function.

### **Directory Structure**
```
game/src/template/weather/
â”œâ”€â”€ types.ts              # WeatherDescription, WeatherReducer types
â”œâ”€â”€ reducers/
â”‚   â”œâ”€â”€ solar.ts          # applySolarGeometry reducer
â”‚   â”œâ”€â”€ solar.spec.ts     # Unit tests for solar reducer
â”‚   â”œâ”€â”€ clouds.ts         # applyCloudCover reducer
â”‚   â”œâ”€â”€ clouds.spec.ts    # Unit tests for clouds reducer
â”‚   â”œâ”€â”€ scattering.ts     # applyAtmosphericScattering reducer
â”‚   â”œâ”€â”€ scattering.spec.ts # Unit tests for scattering reducer
â”‚   â”œâ”€â”€ precipitation.ts  # applyPrecipitation reducer
â”‚   â”œâ”€â”€ precipitation.spec.ts # Unit tests for precipitation reducer
â”‚   â”œâ”€â”€ narrative.ts      # enhanceNarrative reducer
â”‚   â”œâ”€â”€ narrative.spec.ts # Unit tests for narrative reducer
â”‚   â”œâ”€â”€ render.ts         # renderFinalDescription reducer
â”‚   â””â”€â”€ render.spec.ts    # Unit tests for render reducer
â”œâ”€â”€ transitions/
â”‚   â”œâ”€â”€ meaningful.ts     # meaningfulTransitions definitions
â”‚   â”œâ”€â”€ meaningful.spec.ts # Unit tests for meaningful transitions
â”‚   â”œâ”€â”€ detection.ts      # transitionDetection logic
â”‚   â””â”€â”€ detection.spec.ts # Unit tests for detection logic
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ time.ts           # time-related utilities
â”‚   â”œâ”€â”€ time.spec.ts      # Unit tests for time utilities
â”‚   â”œâ”€â”€ ppfd.ts           # PPFD calculations
â”‚   â””â”€â”€ ppfd.spec.ts      # Unit tests for PPFD calculations
â”œâ”€â”€ index.ts              # Main describeWeather function
â””â”€â”€ index.spec.ts         # Integration tests for main function
```

### **Migration Tasks**
The existing `describeWeather` function needs to be reorganized and properly implemented:

1. **Move existing code**: `game/src/template/weather.ts` â†’ `game/src/template/weather/legacy.ts` (for reference)
2. **Implement new `describeWeather`** in `game/src/template/weather/index.ts` using the reducer pipeline
3. **Update imports** across the codebase from `~/template/weather` to `~/template/weather/index`
4. **Preserve function signature** - `describeWeather: Template<DescribeWeatherProps>` stays the same

The public API remains unchanged - only the internal implementation uses the new reducer system.

## ğŸ—ï¸ **Architectural Constraints**

### **Testing Strategy**
- **Co-located tests**: All unit tests are placed adjacent to the module under test
- **Test file naming**: Use `.spec.ts` extension for all test files
- **Test coverage**: Every module must have happy path tests, at minimum
- **Test approach**: Test only inputs and outputs. We are not interested in internals.
- **Isolated testing**: Each reducer can be tested independently as a pure function

### **Code Quality Standards**
- **Pure functions only**: All functions must be pure with no side effects
- **Injected impurity**: When side effects are needed, inject them as parameters
- **No global state**: Pass all dependencies explicitly
- **Immutable data**: Use immutable data structures and transformations

### **Performance-First Posture**
- **Optimize for common cases**: Focus on the most frequent weather transitions
- **Minimize allocations**: Reuse objects where possible, avoid unnecessary array/object creation
- **Efficient algorithms**: Use O(1) lookups over O(n) searches
- **Lazy evaluation**: Only compute expensive operations when needed
- **Benchmark critical paths**: Measure performance of core reducer pipeline

### **Example Pure Function Pattern**
```typescript
// âœ… Pure function - predictable, testable, fast
export const applySolarGeometry = (
  acc: WeatherDescription,
  prev: Weather,
  current: Weather,
  timeUtils: TimeUtils = defaultTimeUtils  // Injected dependency
): WeatherDescription => {
  // Pure transformation logic
  return { ...acc, /* changes */ };
};

// âŒ Avoid - impure function with hidden dependencies
export const applySolarGeometry = (acc: WeatherDescription) => {
  const now = Date.now(); // Hidden side effect!
  // ...
};
```

This system provides rich, contextual weather descriptions while remaining maintainable and extensible.
