# Prompt: Dual Module System Compatibility (CommonJS + ESM)

I am implementing dual module system compatibility for the `flux-game` package to support both CommonJS and ESM consumers.

## Current Status: CommonJS Only

### âœ… Current Build Configuration

**Package Configuration:**
- `package.json`: `"type": "commonjs"` with `"main": "dist/index.js"`
- `tsconfig.json`: `"module": "commonjs"`
- **Output**: Single CommonJS build in `dist/` directory
- **Limitation**: Only works with `require()` or dynamic `import()`

**Build Process:**
```bash
npm run build
# Outputs: dist/index.js (CommonJS) + dist/index.d.ts (TypeScript declarations)
```

**Current Consumers:**
- âœ… CommonJS: `const { generateWorld } = require('flux-game')`
- âŒ ESM: `import { generateWorld } from 'flux-game'` (doesn't work)

### ğŸš¨ **CRITICAL CONSTRAINT: NO BREAKING CHANGES**

**Real Production Consumers:**
- The `flux-game` package has **actual consumers in production**
- These consumers depend on the current CommonJS export structure
- **ANY breaking change will cause production failures**
- The existing API surface must remain 100% compatible

**Non-Negotiable Requirements:**
- âœ… `require('flux-game')` must continue working exactly as before
- âœ… All current exports must remain available and functional
- âœ… TypeScript types must remain compatible
- âœ… No changes to the existing API surface
- âœ… No changes to export names or structure

## Goal: Option 1 - Dual Package.json Approach

### ğŸ¯ Target Configuration

**Package.json Structure:**
```json
{
  "type": "commonjs",
  "main": "./dist/cjs/index.js",
  "module": "./dist/esm/index.js",
  "types": "./dist/types/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/esm/index.js",
      "require": "./dist/cjs/index.js",
      "types": "./dist/types/index.d.ts"
    }
  }
}
```

**Build Output Structure:**
```
dist/
â”œâ”€â”€ cjs/           # CommonJS build
â”‚   â”œâ”€â”€ index.js
â”‚   â””â”€â”€ ...
â”œâ”€â”€ esm/           # ESM build
â”‚   â”œâ”€â”€ index.js
â”‚   â””â”€â”€ ...
â””â”€â”€ types/         # Shared TypeScript declarations
    â”œâ”€â”€ index.d.ts
    â””â”€â”€ ...
```

**Target Consumers:**
- âœ… CommonJS: `const { generateWorld } = require('flux-game')`
- âœ… ESM: `import { generateWorld } from 'flux-game'`
- âœ… TypeScript: Full type support for both systems

### ğŸ”§ Implementation Requirements

**1. TypeScript Configuration:**
- `tsconfig.cjs.json`: Targets CommonJS output (`"module": "commonjs"`)
- `tsconfig.esm.json`: Targets ESM output (`"module": "es2020"`)
- `tsconfig.types.json`: Generates shared type declarations

**2. Build Scripts:**
```json
{
  "scripts": {
    "build": "npm run build:clean && npm run build:cjs && npm run build:esm && npm run build:types",
    "build:clean": "rm -rf ./dist",
    "build:cjs": "tsc --project tsconfig.cjs.json && tsc-alias -p tsconfig.cjs.json",
    "build:esm": "tsc --project tsconfig.esm.json && tsc-alias -p tsconfig.esm.json",
    "build:types": "tsc --project tsconfig.types.json && tsc-alias -p tsconfig.types.json"
  }
}
```

**3. Package.json Updates:**
- Add `"module"` field pointing to ESM build
- Add `"exports"` with conditional exports for both systems
- Update `"main"` to point to CommonJS build in new location
- Update `"types"` to point to shared declarations

### ğŸ§ª Testing Strategy

**Validation Requirements:**
- âœ… CommonJS import: `const game = require('flux-game')`
- âœ… ESM import: `import * as game from 'flux-game'`
- âœ… Named ESM import: `import { generateWorld } from 'flux-game'`
- âœ… Dynamic import: `const game = await import('flux-game')`
- âœ… TypeScript IntelliSense works for both systems
- âœ… Tree-shaking works with ESM builds

**Test Files:**
- `test-cjs.js`: CommonJS consumer test
- `test-esm.mjs`: ESM consumer test
- Verify both can import and use the library

### ğŸš€ Benefits of Option 1

**Backward Compatibility (CRITICAL):**
- **ZERO breaking changes** - existing CommonJS consumers continue working exactly as before
- **Production safety** - no risk of breaking existing deployments
- **API preservation** - all current exports remain identical
- **Type compatibility** - TypeScript consumers experience no changes

**Future Compatibility:**
- ESM consumers can use modern import syntax
- Better tree-shaking support for bundlers
- Aligns with JavaScript ecosystem direction

**Industry Standard:**
- Same approach used by major libraries (lodash, axios, etc.)
- Well-supported by bundlers and Node.js
- Clear separation of concerns
- **Proven safe migration path** for packages with existing consumers

### ğŸ“ File Structure

**Current:**
```
game/
â”œâ”€â”€ package.json          # "type": "commonjs", "main": "dist/index.js"
â”œâ”€â”€ tsconfig.json         # "module": "commonjs"
â”œâ”€â”€ tsconfig.build.json   # Extends tsconfig.json
â””â”€â”€ dist/                 # Single CommonJS build
    â”œâ”€â”€ index.js
    â””â”€â”€ index.d.ts
```

**Target:**
```
game/
â”œâ”€â”€ package.json          # Updated with conditional exports
â”œâ”€â”€ tsconfig.json         # Base configuration
â”œâ”€â”€ tsconfig.cjs.json     # CommonJS build config
â”œâ”€â”€ tsconfig.esm.json     # ESM build config
â”œâ”€â”€ tsconfig.types.json   # Type declarations config
â””â”€â”€ dist/                 # Dual build output
    â”œâ”€â”€ cjs/              # CommonJS build
    â”‚   â”œâ”€â”€ index.js
    â”‚   â””â”€â”€ ...
    â”œâ”€â”€ esm/              # ESM build
    â”‚   â”œâ”€â”€ index.js
    â”‚   â””â”€â”€ ...
    â””â”€â”€ types/            # Shared type declarations
        â”œâ”€â”€ index.d.ts
        â””â”€â”€ ...
```

## Implementation Steps

1. **Create TypeScript Configurations**
   - `tsconfig.cjs.json` for CommonJS build
   - `tsconfig.esm.json` for ESM build
   - `tsconfig.types.json` for type declarations

2. **Update Package.json**
   - Add `"module"` field
   - Add `"exports"` with conditional exports
   - Update build scripts for dual builds
   - Update file paths for new structure

3. **Update Build Process**
   - Modify build scripts to generate both formats
   - Ensure `tsc-alias` works with both builds
   - Clean up old build artifacts

4. **Test Compatibility**
   - Create test files for both module systems
   - Verify imports work correctly
   - Test TypeScript IntelliSense

5. **Documentation**
   - Update README with usage examples for both systems
   - Document the dual build approach

## Architecture Principles

1. **Backward Compatibility (PARAMOUNT)**: Existing consumers must continue working with ZERO changes
2. **Production Safety**: No risk of breaking existing deployments or consumers
3. **API Preservation**: All current exports must remain identical and functional
4. **Future-Proof**: Support modern ESM imports without affecting existing usage
5. **Type Safety**: Full TypeScript support for both systems with no breaking changes
6. **Performance**: Enable tree-shaking for ESM consumers while maintaining CommonJS performance
7. **Standards Compliance**: Follow Node.js conditional exports specification

## Success Criteria

### ğŸš¨ **MANDATORY (Production Safety)**
- âœ… **Existing CommonJS consumers work EXACTLY as before** - no changes required
- âœ… **All current exports remain functional** - no API surface changes
- âœ… **TypeScript types remain compatible** - no breaking type changes
- âœ… **Production deployments continue working** - zero downtime migration

### ğŸ¯ **Additional Goals**
- âœ… New ESM consumers can use modern import syntax
- âœ… TypeScript IntelliSense works for both systems
- âœ… Bundle size is reasonable (not significantly larger)
- âœ… Build process is reliable and maintainable
- âœ… Package works correctly in Node.js, browsers, and bundlers

### ğŸ”’ **Validation Requirements**
- âœ… **Regression Testing**: All existing consumer patterns must pass
- âœ… **API Compatibility**: Every current export must work identically
- âœ… **Type Compatibility**: TypeScript consumers see no breaking changes
- âœ… **Performance Parity**: CommonJS performance must not degrade

The goal is to create a seamless dual-module package that works everywhere while **maintaining 100% backward compatibility** for existing production consumers and adding modern ESM support for new consumers.
