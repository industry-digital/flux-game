# Weather Description System

## ğŸŒ¤ï¸ **Overview**

The Weather Description System generates human-readable descriptions of atmospheric changes using a functional reducer pipeline. Instead of describing static weather states, it focuses on meaningful transitions that affect player experience.

## ğŸš¨ **The Combinatorial Explosion Problem**

### **How We Got Here**
When designing a system to describe atmospheric changes, we initially considered modeling individual weather phenomena separately:

- **Solar geometry** - sunrise, sunset, solar angle changes
- **Cloud dynamics** - gathering, clearing, density changes
- **Light interactions** - PPFD changes, scattering effects
- **Atmospheric conditions** - humidity, pressure, seasonal effects
- **Precipitation** - rain starting/stopping, intensity changes

### **The Mathematical Reality**
With N independent phenomena, we face **2^N possible combinations**:

```typescript
// Just 5 phenomena = 32 combinations
const phenomena = [
  'solar-transition',    // sunrise, sunset, solar-noon
  'cloud-change',        // gathering, clearing, stable
  'light-change',        // brightening, dimming, stable
  'atmospheric-shift',   // humidity, pressure changes
  'precipitation-event'  // rain, snow, clearing
];

// Possible combinations: 2^5 = 32
// Example problematic combinations:
// - Sunrise + clouds gathering + light dimming + high pressure + rain starting
// - Sunset + clouds clearing + light brightening + low humidity + snow stopping
// - Solar noon + stable clouds + stable light + pressure drop + no precipitation
```

### **Why This Doesn't Work**
1. **Template explosion** - Need to write descriptions for 32+ combinations
2. **Nonsensical combinations** - Many combinations don't make physical sense
3. **Maintenance nightmare** - Adding one phenomenon doubles the combinations
4. **Poor player experience** - Most combinations are uninteresting to players
5. **Diminishing returns** - 90% of combinations would rarely occur

### **The Insight**
Most combinations are either:
- **Physically impossible** - "bright sunshine during heavy storm"
- **Redundant** - "light brightening" + "clouds clearing" say the same thing
- **Uninteresting** - "stable conditions across all phenomena"
- **Too complex** - descriptions become unwieldy with many simultaneous changes

## ğŸ¯ **Core Philosophy**

### **Meaningful Transitions Only**
We solve the combinatorial explosion by identifying only atmospheric transitions that are meaningful to a human player:

- **Dramatic visibility changes** - affect what players can see/do
- **Weather events that signal change** - storms approaching/clearing
- **Time transitions with emotional weight** - dawn, dusk, golden hour
- **Atmospheric mood shifts** - eerie stillness, oppressive air, crisp clarity

This constrains us to ~15-20 meaningful scenarios instead of hundreds of theoretical combinations.

## ğŸ—ï¸ **Architecture**

### **Reducer Pipeline**
The `describeWeather` function internally uses this reducer pipeline:

```typescript
// Internal implementation - called by describeWeather
const describeWeatherChangeImpl = (
  context: WeatherReducerContext,
  current: Weather,
): string => {

  const finalContext = [
    applySolarGeometry,           // Sun angle, sunrise/sunset timing
    applyCloudCover,             // Cloud density effects on light
    applyPrecipitation,          // Rain/weather event transitions
    applyFog,                    // Fog formation/dissipation
    enhanceNarrative,            // Cross-phenomenon interactions
    renderFinalDescription       // Final composition
  ].reduce((context, reducer) => reducer(context, current), initialContext);

  return finalContext.narrative.join('. ').replace(/\.\./g, '.');
};

// Public API
export type DescribeWeatherChangeProps = Partial<PotentiallyImpureOperations> & {
  previous?: Weather;
  current: Weather;
};

export const describeWeatherChange: Template<DescribeWeatherChangeProps> = (props) => {
  if (!props.previous) return ''; // No change to describe
  if (!isValidWeather(props.current) || !isValidWeather(props.previous)) return ''; // Invalid inputs

  const context: WeatherReducerContext = {
    ...props,
    previous: props.previous,
    debug: props.debug,
    random: props.random,
    timestamp: props.timestamp,
    uniqid: props.uniqid,
  };

  return describeWeatherChangeImpl(context, props.current);
};
```

### **Output Format: Multiple Atmospheric Sentences**

Our approach generates **multiple complete sentences** rather than trying to merge complex fragments:

```typescript
// Example outputs:
const narratives = [
  "Dawn breaks across the horizon, painting the sky in soft pastels",
  "Storm clouds gather overhead",
  "The air grows heavy with moisture"
];

// Joined: "Dawn breaks across the horizon, painting the sky in soft pastels. Storm clouds gather overhead. The air grows heavy with moisture."
```

**Benefits**:
- **Eliminates fragment coordination complexity** - no complex grammar rules needed
- **Robust independent sentences** - each reducer generates complete thoughts
- **Natural merging when obvious** - reducers can still combine sentences when it flows naturally
- **Variable output length** - 1-4 sentences depending on atmospheric activity

### **Core Types**
```typescript
type WeatherDescription = {
  narrative: string[];           // Complete sentences, joined with periods
  descriptors: {
    timeOfDay: 'dawn' | 'day' | 'dusk' | 'night';
    timeTransition?: 'sunrise' | 'sunset' | 'deepening';
    cloudChange?: 'clearing' | 'gathering' | 'stable';
    lightChange?: 'brightening' | 'dimming' | 'stable';
    precipitationChange?: 'starting' | 'intensifying' | 'lessening' | 'stopping' | 'stable';
    fogChange?: 'forming' | 'dissipating' | 'stable';
    mood: 'peaceful' | 'dramatic' | 'ominous' | 'neutral';
  };
  intensity: number;             // 0-1, how dramatic the change is
};

type WeatherReducerContext = PotentiallyImpureOperations & WeatherDescription & {
  previous: Weather;
};

type WeatherReducer = (
  context: WeatherReducerContext,
  current: Weather
) => WeatherReducerContext;
```

## ğŸ”§ **Reducer Functions**

### **Physical Phenomenon Reducers**
Each reducer models a specific physical process:

```typescript
const applySolarGeometry: WeatherReducer = (context, current) => {
  // Handle sun elevation angle, sunrise/sunset, solar noon effects
  const prevHour = new Date(context.previous.ts).getHours();
  const currHour = new Date(current.ts).getHours();

  if (prevHour < 6 && currHour >= 6) {
    context.debug('Dawn transition detected');
    return {
      ...context,
      descriptors: { ...context.descriptors, timeTransition: 'sunrise' },
      narrative: [...context.narrative, 'Dawn breaks across the horizon, painting the sky in soft pastels'],
      intensity: Math.max(context.intensity, 0.6)
    };
  }

  return context;
};

const applyCloudCover: WeatherReducer = (context, current) => {
  // Handle how clouds interact with direct/diffuse light
  const cloudDelta = current.clouds - context.previous.clouds;

  if (cloudDelta > 30) {
    context.debug('Storm clouds gathering');
    return {
      ...context,
      descriptors: { ...context.descriptors, cloudChange: 'gathering' },
      narrative: [...context.narrative, 'Storm clouds gather overhead'],
      intensity: Math.max(context.intensity, 0.4)
    };
  }

  return context;
};
```

### **Enhancement Reducers**
Later reducers can rewrite or enhance earlier decisions:

```typescript
const enhanceNarrative: WeatherReducer = (context, current) => {
  // Look for meaningful combinations and merge when natural
  if (context.descriptors.timeTransition === 'sunrise' && context.descriptors.cloudChange === 'gathering') {
    context.debug('Merging dawn and storm cloud descriptions');
    // Replace the last two sentences with a merged version
    const enhanced = 'Dawn struggles through gathering storm clouds, casting an eerie gray light over the landscape';
    return {
      ...context,
      narrative: [...context.narrative.slice(0, -2), enhanced],
      descriptors: { ...context.descriptors, mood: 'ominous' }
    };
  }

  return context;
};
```

## ğŸ¨ **Meaningful Atmospheric Transitions**

### **High-Impact Transitions**
1. **Dawn through storm clouds** - "Dawn struggles through heavy overcast"
2. **Sun breaks through** - "Sunlight bursts through, illuminating the landscape"
3. **Storm approaching** - "Dark clouds swallow the sun, bringing premature twilight"
4. **Golden hour** - "The setting sun bathes everything in honey-colored light"
5. **Twilight deepening** - "Twilight deepens into true darkness"

### **Atmospheric Mood Shifts**
1. **Eerie stillness** - "An oppressive calm settles over the land"
2. **Crisp clarity** - "Crystal-clear air makes distant mountains seem close"
3. **Thick atmosphere** - "The air grows heavy and humid"

### **Weather Event Signals**
1. **Storm building** - "Thunder rumbles in the distance"
2. **Storm breaking** - "The first fat raindrops begin to fall"
3. **Storm clearing** - "Storm clouds part, revealing patches of blue sky"

### **Precipitation Transitions**
Rain directly affects gameplay mechanics, making these transitions critical:

1. **Rain beginning** - "A light drizzle begins to fall from the gray sky"
2. **Rain intensifying** - "The gentle rain becomes a steady downpour"
3. **Heavy rain starting** - "Heavy drops drum against the ground with increasing intensity"
4. **Rain lessening** - "The downpour eases to a gentle patter"
5. **Rain stopping** - "The last raindrops fall as the clouds begin to part"
6. **Mist/fog forming** - "A fine mist rises from the wet ground"

## ğŸ“Š **Implementation Benefits**

### **Maintainability**
- **Pure functions** - Each reducer is testable in isolation
- **Single responsibility** - Each reducer handles one physical phenomenon
- **Composable** - Easy to reorder, add, or remove reducers
- **Clear naming** - Function names reflect physical processes

### **Extensibility**
Adding new weather phenomena requires only adding new reducers:
```typescript
const description = [
  applySolarGeometry,
  applyCloudCover,
  applyPrecipitation,
  applyWindChanges,      // New!
  applyTemperatureShifts, // New!
  applyAurora,           // New!
  enhanceNarrative,
  renderFinalDescription
].reduce((context, reducer) => reducer(context, current), initialContext);
```

### **Flexibility**
- **Context-aware** - Later reducers see what earlier ones detected
- **Incremental** - Narrative builds up piece by piece
- **Rewritable** - Enhancement steps can completely rewrite earlier decisions

## ğŸš€ **Usage Examples**

### **Simple Time Transition**
```typescript
// Input: 5:45 AM â†’ 6:15 AM, clear skies
// Output: "Dawn breaks across the horizon, painting the sky in soft pastels."
```

### **Complex Interaction**
```typescript
// Input: Dawn + gathering storm clouds + dropping PPFD
// Output: "Dawn struggles to break through gathering storm clouds, casting an eerie gray light over the landscape."
```

### **Dramatic Weather Event**
```typescript
// Input: Midday + rapid cloud buildup + PPFD drops 80%
// Output: "Dark storm clouds suddenly swallow the sun, plunging the area into premature twilight."
```

## ğŸ¯ **Design Principles**

1. **Focus on Player Experience** - Only describe changes that matter to someone in this world
2. **Physical Accuracy** - Base descriptions on real atmospheric phenomena
3. **Narrative Weight** - Emphasize transitions with emotional or gameplay significance
4. **Compositional** - Build complex descriptions from simple, reusable parts
5. **Maintainable** - Keep reducers focused and pure for easy testing/modification
6. **Atmospheric Focus** - Describe the weather phenomena as experienced, not their gameplay consequences

### **Separation of Concerns**
The weather description system describes **what players perceive**, not **what happens mechanically**:

- âœ… **Good**: "Heavy rain drums against the ground"
- âŒ **Bad**: "Heavy rain forms puddles that slow movement"
- âœ… **Good**: "A thick fog rolls in, reducing visibility"
- âŒ **Bad**: "Fog appears, reducing your vision range to 2 tiles"

Let the game mechanics handle mechanical effects. The description system focuses on atmospheric immersion.

## ğŸ“ **Implementation Notes**

- **PPFD Integration** - Use PPFD values (0-2000 Î¼mol/mÂ²/s) to drive light-based descriptions
- **Time Sensitivity** - Factor in realistic sunrise/sunset times based on season/location
- **Weather Correlation** - Ensure cloud cover and PPFD changes are consistent
- **Intensity Scaling** - More dramatic changes get more elaborate descriptions
- **Fragment Quality** - Each narrative fragment should be a well-formed sentence component
- **Natural Transition Thresholds** - Research real-world atmospheric thresholds for meaningful weather changes
- **Copying from Mother Nature** - Base all transition detection on observable natural phenomena

### **Atmospheric Threshold Research**

Based on meteorological research and human perception studies, meaningful atmospheric thresholds include:

**PPFD (Photosynthetic Photon Flux Density)**
- **Dawn/Twilight**: 50-200 Î¼mol/mÂ²/s (low light transitions)
- **Overcast conditions**: 400-800 Î¼mol/mÂ²/s (cloudy but adequate light)
- **Bright sunlight**: 1800-2000 Î¼mol/mÂ²/s (optimal plant growth)
- **McCree peaks**: 440nm (blue) and 620nm (red) for plant response

**Precipitation Intensity** (mm/hour)
- **Fog/Mist**: 0 mm/h (suspended droplets, visibility-based classification)
- **Light drizzle**: <0.25 mm/h (barely measurable precipitation)
- **Moderate drizzle**: 0.25-0.5 mm/h (fine droplets, significant visibility reduction)
- **Heavy drizzle**: 0.5-2.5 mm/h (persistent light precipitation)
- **Light rain**: 2.5-10 mm/h (steady rainfall, visible effect)
- **Heavy rain**: 10-25 mm/h (significant impact on activities)
- **Very heavy rain**: 25-50 mm/h (torrential, severe disruption)
- **Extreme rain**: >50 mm/h (causes flooding, emergency conditions)

**Cloud Cover** (percentage of sky covered, based on WMO oktas system)
- **Clear**: 0-10% (0-1 oktas, minimal cloud cover)
- **Scattered**: 10-50% (1-4 oktas, partial cloud cover, variable light)
- **Broken**: 50-75% (4-6 oktas, majority cloud cover, reduced sunlight)
- **Mostly cloudy**: 75-90% (6-7 oktas, extensive cloud cover, limited sunlight)
- **Overcast**: 90-100% (7-8 oktas, complete cloud cover)

**Atmospheric Pressure** (mbar/hPa)
- **High pressure**: >1022 mbar (fair weather, stable conditions)
- **Normal pressure**: 1009-1022 mbar (typical conditions)
- **Low pressure**: <1009 mbar (storms, precipitation likely)
- **Rapid change**: >3-5 mbar/hour (weather front approaching)

**Temperature Transitions** (Â°C)
- **Human comfort range**: 20-23Â°C winter, 23-26Â°C summer
- **Perceptible change**: 2-3Â°C difference noticeable by humans
- **Frost threshold**: 0Â°C (critical agricultural/ecological boundary)

**Humidity Levels** (relative humidity %)
- **Comfortable**: 40-60% RH (optimal human comfort)
- **Dry conditions**: <30% RH (discomfort, static electricity)
- **Muggy conditions**: >70% RH (oppressive, affects temperature perception)
- **Note**: 80% RH makes 21Â°C feel like 24Â°C to humans


## ğŸ“ **Implementation Location**

**All weather description system implementation must be placed in:**
```
game/src/template/weather/
```

### **Public API**
The weather directory exports a **single function** that the rest of the game uses:

```typescript
// game/src/template/weather/index.ts
export const describeWeather: Template<DescribeWeatherProps> = (props) => {
  // All reducer pipeline implementation happens here
  return describeWeatherChange(props.previous, props.current);
};
```

**Everything else is internal implementation.** The reducer pipeline, meaningful transitions, PPFD calculations - all of that supports this one function.

### **Directory Structure**
```
game/src/template/weather/
â”œâ”€â”€ types.ts              # WeatherDescription, WeatherReducer types
â”œâ”€â”€ reducers/
â”‚   â”œâ”€â”€ solar.ts          # applySolarGeometry reducer
â”‚   â”œâ”€â”€ clouds.ts         # applyCloudCover reducer
â”‚   â”œâ”€â”€ precipitation.ts  # applyPrecipitation reducer
â”‚   â”œâ”€â”€ narrative.ts      # enhanceNarrative reducer
â”‚   â””â”€â”€ final.ts         # renderFinalDescription reducer
â”œâ”€â”€ transitions/
â”‚   â”œâ”€â”€ meaningful.ts     # meaningfulTransitions definitions
â”‚   â””â”€â”€ detection.ts      # transitionDetection logic
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ time.ts           # time-related utilities
â”‚   â””â”€â”€ ppfd.ts           # PPFD calculations
â”œâ”€â”€ index.ts              # Main describeWeather function
â””â”€â”€ index.spec.ts         # Comprehensive tests for describeWeather
```

### **Migration Tasks**
The existing `describeWeather` function needs to be reorganized and properly implemented:

1. **Move existing code**: `game/src/template/weather.ts` â†’ `game/src/template/weather/legacy.ts` (for reference)
2. **Implement new `describeWeather`** in `game/src/template/weather/index.ts` using the reducer pipeline
3. **Update imports** across the codebase from `~/template/weather` to `~/template/weather/index`
4. **Preserve function signature** - `describeWeather: Template<DescribeWeatherProps>` stays the same

The public API remains unchanged - only the internal implementation uses the new reducer system.

## ğŸ—ï¸ **Architectural Constraints**

### **Testing Strategy**
- **Focus on public API**: Comprehensive tests for `describeWeather` function only
- **Integration testing**: Test complete reducer pipeline through the main function
- **Test file naming**: Single `index.spec.ts` file co-located with main implementation
- **Test approach**: Test inputs and outputs of complete system, not individual reducers
- **Property-based testing**: Verify meaningful transitions and anti-equilibrium properties

### **Code Quality Standards**
- **Pure functions only**: All functions must be pure with no side effects
- **Injected impurity**: Use existing `PotentiallyImpureOperations` pattern for random, debug, timestamps
- **No global state**: Pass all dependencies explicitly
- **Immutable data**: Use immutable data structures and transformations
- **Architectural alignment**: Follow established codebase patterns for dependency injection
- **Error handling**: Template functions return empty string for invalid inputs - no exceptions

### **Performance-First Posture**
- **Maximum algorithmic efficiency**: Prioritize algorithmic efficiency where benefits are obvious
- **Memory-speed trade-offs**: Trade memory for speed when beneficial (lookup tables, precomputed values)
- **Efficient algorithms**: Use O(1) lookups over O(n) searches
- **Minimize allocations**: Reuse objects where possible, avoid unnecessary array/object creation
- **Lazy evaluation**: Only compute expensive operations when needed

### **Example Pure Function Pattern**

All functions must be pure, no exceptions. Wherever we need impurity, we inject it.

```typescript
// âœ… Pure function using refined reducer interface
export const applySolarGeometry: WeatherReducer = (context, current) => {
  // All impurity available through context (ops spread into context)
  // Available: context.random(), context.timestamp(), context.uniqid(), context.debug()
  const randomVariation = context.random() * 0.1; // Atmospheric variation
  context.debug('Solar geometry transition detected');

  // Pure transformation logic
  return { ...context, /* changes */ };
};

// âŒ Avoid - impure function with hidden dependencies
export const applySolarGeometry = (acc: WeatherDescription) => {
  const now = Date.now(); // Hidden side effect!
  const random = Math.random(); // Hidden randomness!
  console.log('Solar geometry transition detected', now, random); // Hidden side effect!
  throw new Error('Invalid input'); // Never throw - return empty string instead
};
```

This system provides rich, contextual weather descriptions while remaining maintainable and extensible.
```
