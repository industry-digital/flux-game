# Flux World Generation Tooling

## Project Goal

Implement tooling in the `game` project to procedurally generate a natural world graph of approximately 1000 Places. This tooling creates the foundational layer of wilderness and natural environments that forms the base for later civilization placement.

## Core Architecture

### Ecosystem Schema Approach
Instead of infinite permutations of climate × biome × resources, we use **pre-defined ecosystem schemas** that represent curated, balanced combinations:


Ecosystem name is a Flux URN of exact token length `4`.
```
flux:ecosystem:${biome}:${climate}
```

```typescript
export enum EcosystemName {
  DESERT_CALDERA = 'flux:eco:desert:caldera',
  ARID_SCRUBLAND = 'flux:eco:scrubland:arid',
  TEMPERATE_GRASSLAND = 'flux:eco:grassland:temperate',
  TEMPERATE_FOREST = 'flux:eco:forest:temperate',
  ALPINE_WOODLAND = 'flux:eco:woodland:alpine',
};

type EcosystemSchema = ResourceGenerator & {
  name: EcosystemName;
};
```

### Continuum-Based Generation
Ecosystem schemas are organized into **continuums** that enable smooth geographic transitions along a single axis. Each continuum element is represented as a tuple `[EcosystemName, NormalizedValue]` where the value ranges from -1.0 to +1.0:

```typescript
// Each element is [EcosystemName, NormalizedValue]
type ContinuumElement = [EcosystemName, number]; // -1.0 to +1.0

// Temperature continuum (coldest → warmest)
const TEMPERATURE_CONTINUUM: ContinuumElement[] = [
  [EcosystemName.ALPINE_WOODLAND, -1.0],        // Coldest extreme
  [EcosystemName.TEMPERATE_FOREST, 0.0],
  [EcosystemName.TEMPERATE_GRASSLAND, 0.0],     // Moderate baseline
  [EcosystemName.ARID_SCRUBLAND, 0.5],
  [EcosystemName.DESERT_CALDERA, 1.0]           // Warmest extreme
];

// Moisture continuum (driest → wettest)
const MOISTURE_CONTINUUM: ContinuumElement[] = [
  [EcosystemName.DESERT_CALDERA, -1.0],       // Driest extreme
  [EcosystemName.ARID_SCRUBLAND, -0.6],
  [EcosystemName.TEMPERATE_GRASSLAND, -0.2],
  [EcosystemName.ALPINE_WOODLAND, 0.0],       // Moderate baseline
  [EcosystemName.TEMPERATE_FOREST, 0.4]       // Wettest extreme
];

// Elevation continuum (lowest → highest)
const ELEVATION_CONTINUUM: ContinuumElement[] = [
  [EcosystemName.DESERT_CALDERA, -1.0],        // Lowest extreme
  [EcosystemName.TEMPERATE_GRASSLAND, -0.4],
  [EcosystemName.ARID_SCRUBLAND, -0.1],
  [EcosystemName.TEMPERATE_FOREST, 0.0],       // Moderate baseline
  [EcosystemName.ALPINE_WOODLAND, 1.0]         // Highest extreme
];

type GeographicProfile = {
  temperature: number;    // -1.0 to +1.0
  moisture: number;       // -1.0 to +1.0
  elevation: number;      // -1.0 to +1.0
  vegetation: number;     // -1.0 to +1.0
}
```

### Rule-Based Generation
Core world structure is generated through **mathematical rules**.

- Ecosystem placement using continuum positions
- Smooth transitions between adjacent places using the `interpolateEcosystems` function
- Biome-appropriate connectivity patterns
- Bidirectional edges for all connections
- Vertical connectivity for mountainous biomes using `Direction.UP` and `Direction.DOWN` exits (peaks, valleys, plateaus, cliff faces)
- Resource distribution based on ecosystem schemas

### Weather Service Integration Benefits
The normalized continuum values (-1.0 to +1.0) provide quantitative data for sophisticated weather modeling:

```typescript
// Weather intensity based on ecosystem extremeness
const calculateWeatherIntensity = (ecosystem: string): WeatherModifiers => {
  const profile: GeographicProfile = GEOGRAPHIC_PROFILES[ecosystem];
  // Do something interesting with the profile...
};

// Smooth interpolation between ecosystem positions
const interpolateEcosystems = (from: string, to: string, steps: number): string[] => {
  const fromProfile = GEOGRAPHIC_PROFILES[from];
  const toProfile = GEOGRAPHIC_PROFILES[to];

  const interpolatedPositions = [];
  for (let i = 0; i < steps; i++) {
    const ratio = i / (steps - 1);
    const interpolated = {
      temperature: fromProfile.temperature + (toProfile.temperature - fromProfile.temperature) * ratio,
      moisture: fromProfile.moisture + (toProfile.moisture - fromProfile.moisture) * ratio,
      elevation: fromProfile.elevation + (toProfile.elevation - fromProfile.elevation) * ratio,
      vegetation: fromProfile.vegetation + (toProfile.vegetation - fromProfile.vegetation) * ratio
    };
    interpolatedPositions.push(findClosestEcosystem(interpolated));
  }

  return interpolatedPositions;
};
```

## Key Design Principles

### Integration with Existing Types
- **Place**: Extend existing Place type with climate, biome, and ResourceGenerator
- **ResourceGenerator**: Use existing resource generation system
- **Pure Functions**: All generation logic is deterministic and testable
- **Taxonomic URNs**: Follow established URN patterns for resource types

### Natural World Focus
- **Wilderness Only**: Generate natural environments, not settlements
- **Geographic Coherence**: Adjacent places have compatible ecosystems
- **Resource Realism**: Resource availability matches ecosystem characteristics
- **Climate Consistency**: Climate patterns follow geographic logic

### Performance Requirements
- **Fast Generation**: Must be able to generate 1000 places quickly
- **Deterministic**: Same parameters produce same world
- **Offline Capable**: No external API dependencies for core generation
- **Memory Efficient**: Generate and stream rather than load entire world

## Implementation Phases

### Phase 1: Ecosystem Schema System
1. Define ecosystem schema interface and standard schemas
2. Create continuum definitions and position mappings
3. Implement ecosystem interpolation and transition logic
4. Build ecosystem-to-Place conversion functions

### Phase 2: World Graph Generation
1. Generate world structure using continuum-based rules
2. Implement smooth transition algorithms between adjacent places
3. Create connectivity patterns with realistic exit generation
4. **Implement vertical connectivity** for mountainous biomes using `Direction.UP`/`Direction.DOWN` exits
5. **Generate biome-appropriate connectivity**: mountainous (~2.1 avg degree), forests (~2.8), plains (~3.5), deserts (~2.3), coastal (~2.6)
6. **Ensure bidirectional edges**: automatically create reciprocal exits for all connections
7. Ensure graph connectivity and navigation paths

### Phase 3: Resource Integration
1. Map ecosystem schemas to ResourceGenerator configurations
2. Implement resource distribution based on climate/biome
3. Create resource variation systems (seasonal, degraded states)
4. Validate resource balance across ecosystem types

### Phase 4: Validation and Tooling
1. Build validation tools for geographic coherence
2. Create visualization tools for generated worlds
3. Implement world export/import functionality
4. Add debugging and inspection capabilities

## Technical Requirements

### File Structure
```
game/src/
  worldgen/
    schemas/          # Ecosystem schema definitions
    continuums/       # Continuum definitions and logic
    generation/       # Core generation algorithms
    validation/       # Coherence checking tools
    export/          # World data export utilities
```

### Key Interfaces
```typescript
// Core generation function
function generateNaturalWorld(config: WorldGenerationConfig): Place[];

// Ecosystem management
function createEcosystemSchema(definition: EcosystemDefinition): EcosystemSchema;
function interpolateEcosystems(from: string, to: string, steps: number): string[];

// Continuum operations
function getEcosystemContinuumValue(ecosystem: string, continuum: string): number;
function findClosestEcosystemByValue(continuum: string, value: number): string;
function findClosestEcosystem(position: EcosystemPosition): string;
function calculateEcosystemDistance(ecosystem1: string, ecosystem2: string): number;

// Connectivity management
function generateBiomeConnectivity(biome: BiomeType): number; // Returns target avg degree
function createBidirectionalExit(fromPlace: Place, toPlace: Place, direction: Direction): void;
function validateBidirectionalConnections(places: Place[]): ValidationResult;

// Validation
function validateWorldCoherence(places: Place[]): ValidationResult;
function checkResourceBalance(places: Place[]): BalanceReport;
function validateContinuumTransitions(places: Place[]): TransitionReport;
```

### Integration Points
- **Place Types**: Must work with existing Place, ClimateType, BiomeType
- **Resource System**: Must use existing ResourceGenerator and ResourceURN patterns
- **Time System**: Must integrate with existing Duration and time modeling
- **Export Format**: Must produce data compatible with server import

## Quality Standards

### Geographic Realism
- Adjacent places have compatible climate/biome combinations
- Resource availability matches ecosystem characteristics
- Elevation and water access follow natural patterns
- Seasonal variations are ecologically appropriate
- **Mountainous biomes** include vertical connectivity using `Direction.UP` and `Direction.DOWN` to represent elevation changes (peaks, valleys, plateaus, cliff faces)
- **Connectivity patterns** match terrain constraints: mountainous biomes have lower average degree (~2.1 connections), while plains/grasslands support higher connectivity (~3.5 connections)
- **Bidirectional edges**: All connections between places are bidirectional by default (if A connects to B, then B connects back to A)

### Game Balance
- Resource distribution supports intended gameplay loops
- No ecosystem type is overpowered or useless
- Travel times and connectivity feel appropriate
- World size supports intended player population
- Vertical movement in mountains creates interesting tactical and exploration opportunities

### Code Quality
- Pure functions with clear inputs/outputs
- Comprehensive test coverage for generation logic
- Documentation for all ecosystem schemas and continuums
- Performance benchmarks for large world generation

## Success Criteria

### Functional Requirements
- Generate 1000-place natural world in under 10 seconds
- All places have valid climate, biome, and resource assignments
- World graph is fully connected with realistic exits
- Resource distribution follows ecosystem schemas accurately

### Quality Requirements
- Adjacent places show smooth ecosystem transitions
- No impossible climate/biome combinations
- Resource availability matches natural patterns
- World feels geographically coherent to players
- Continuum value transitions between adjacent places are <= 0.3
- Ecosystem positions provide meaningful data for Weather Service calculations
- **Connectivity patterns** match biome characteristics: mountainous areas have appropriately low connectivity, plains have higher connectivity
- **All edges are bidirectional** with no orphaned one-way connections

### Technical Requirements
- Code integrates cleanly with existing type system
- Generation is deterministic and reproducible
- Memory usage remains reasonable during generation
- Export format is compatible with server data structures

## Development Guidelines

### Start Simple
Begin with basic ecosystem schemas and simple continuum interpolation. Add complexity gradually as the foundation proves stable.

### Test Continuously
Validate each generation step against geographic realism. Use visualization tools to spot patterns and issues quickly.

### Focus on Rules
Resist the urge to add special cases or manual overrides. Good rules should produce good results consistently.

### Document Decisions
Ecosystem schema choices and continuum arrangements should be well-documented with reasoning for future reference.

The goal is robust, fast tooling that generates believable natural worlds consistently, providing the foundation for rich emergent gameplay and eventual civilization placement.
